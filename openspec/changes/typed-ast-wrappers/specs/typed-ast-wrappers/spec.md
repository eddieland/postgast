## Typed AST Wrappers

### Overview

Typed Python wrapper classes for all protobuf AST node types produced by `postgast.parse()`. Provides Pythonic attribute
access, automatic `Node` oneof unwrapping, and structural pattern matching support.

### Public API

#### `postgast.wrap(tree: ParseResult) -> nodes.ParseResult`

Wraps a raw protobuf `ParseResult` into a typed wrapper tree. All nested nodes are lazily wrapped on property access.

#### `postgast.nodes.AstNode`

Base class for all typed AST wrappers. Holds a reference to the underlying protobuf message in `._pb`.

**Properties:**

- `._pb: Message` — Access the underlying protobuf message (for interop with `deparse()` and raw protobuf APIs)

**Methods:**

- `__repr__() -> str` — Returns `"ClassName(...)"` for readability
- `__eq__(other) -> bool` — Compares by underlying protobuf message equality
- `__hash__() -> int` — Identity-based hash (protobuf messages are mutable, so value-based hashing is unsafe)

#### `postgast.nodes.<NodeType>` (277 classes)

One class per protobuf message type. Each has:

- `__slots__ = ()` — No per-instance dict (memory efficient)
- `__match_args__` — Tuple of field names for structural pattern matching
- Typed `@property` for each field in the protobuf message

**Field type mapping:**

| Protobuf field type              | Wrapper property type                |
| -------------------------------- | ------------------------------------ |
| Scalar (int, bool, str)          | Same scalar type                     |
| Enum                             | Same enum type (from `pg_query_pb2`) |
| Singular message (concrete type) | Corresponding wrapper class          |
| Singular message (`Node` oneof)  | `AstNode \| None` (unwrapped)        |
| Repeated message (concrete type) | `list[WrapperClass]`                 |
| Repeated message (`Node` oneof)  | `list[AstNode]` (each unwrapped)     |

#### `postgast.walk_typed(node: AstNode) -> Generator[tuple[str, AstNode], None, None]`

Like `walk()` but accepts and yields typed wrappers. Depth-first pre-order traversal.

#### `postgast.TypedVisitor`

Like `Visitor` but dispatches to handlers that receive typed wrappers:

```python
class MyVisitor(TypedVisitor):
    def visit_SelectStmt(self, node: nodes.SelectStmt) -> None:
        # `node` is typed, IDE autocomplete works
        for target in node.target_list:
            self.visit(target)
```

### Behavioral Requirements

1. `wrap()` **never returns a `Node` oneof wrapper** — it always unwraps to the concrete inner type
1. Accessing an unset optional message field returns `None`, not an empty protobuf message
1. Accessing a repeated field always returns a `list` (empty list for unset repeated fields)
1. Scalar fields return the same values as the underlying protobuf message
1. `wrap()` is idempotent — wrapping an already-wrapped object returns it unchanged
1. The underlying protobuf message is always accessible via `._pb` for interop
1. `deparse()` accepts both raw protobuf `ParseResult` and wrapped `nodes.ParseResult`
1. Wrapper classes are read-only (no `__setattr__` or property setters)

### Pattern Matching Examples

```python
from postgast import parse, wrap
from postgast.nodes import SelectStmt, InsertStmt, RangeVar

tree = wrap(parse("SELECT * FROM users WHERE active"))

for raw_stmt in tree.stmts:
    match raw_stmt.stmt:
        case SelectStmt(from_clause=tables, where_clause=where):
            print(f"SELECT with {len(tables)} table refs")
            if where is not None:
                print(f"  WHERE clause: {where}")
        case InsertStmt(relation=RangeVar() as rv):
            print(f"INSERT INTO {rv.relname}")
```

### Code Generation

The wrapper classes are generated by `scripts/generate_nodes.py` from the protobuf descriptor. The generated file
`src/postgast/nodes.py` is checked into version control. To regenerate:

```bash
uv run python scripts/generate_nodes.py
```

The generation script is deterministic — running it twice produces identical output. CI verifies freshness via
`make check-nodes`.
