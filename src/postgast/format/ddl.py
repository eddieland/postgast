"""DDL statement visitor methods for the SQL formatter."""

from __future__ import annotations

from typing import cast

import postgast.pg_query_pb2 as pb
from postgast.format.base import _SqlFormatterBase  # pyright: ignore[reportPrivateUsage]
from postgast.walk import _unwrap_node  # pyright: ignore[reportPrivateUsage]


class _DdlMixin(_SqlFormatterBase):
    """Mixin providing DDL statement visitor methods."""

    # ── CREATE TABLE ──────────────────────────────────────────────

    def visit_CreateStmt(self, node: pb.CreateStmt) -> None:
        self._emit("CREATE TABLE ")
        if node.if_not_exists:
            self._emit("IF NOT EXISTS ")
        self._visit_node(node.relation)
        self._emit(" (")
        self._newline()
        self._indent()
        all_elts = list(node.table_elts) + list(node.constraints)
        for i, elt in enumerate(all_elts):
            if i > 0:
                self._emit(",")
                self._newline()
            inner = _unwrap_node(elt)
            if isinstance(inner, pb.ColumnDef):
                self._visit_column_def(inner)
            elif isinstance(inner, pb.Constraint):
                self._visit_constraint(inner)
            else:
                self._visit_node(elt)
        self._newline()
        self._dedent()
        self._emit(")")
        if node.inh_relations:
            self._emit(" INHERITS (")
            self._emit_inline_list(node.inh_relations)
            self._emit(")")

    def _visit_column_def(self, node: pb.ColumnDef) -> None:
        self._emit(f"{node.colname} ")
        self._visit_type_name(node.type_name)
        for cons in node.constraints:
            inner = _unwrap_node(cons)
            if isinstance(inner, pb.Constraint):
                self._emit(" ")
                self._visit_inline_constraint(inner)

    def _visit_inline_constraint(self, node: pb.Constraint) -> None:
        contype = node.contype
        if contype == pb.CONSTR_NOTNULL:
            self._emit("NOT NULL")
        elif contype == pb.CONSTR_NULL:
            self._emit("NULL")
        elif contype == pb.CONSTR_DEFAULT:
            self._emit("DEFAULT ")
            if node.HasField("raw_expr"):
                self._visit_node(node.raw_expr)
        elif contype == pb.CONSTR_CHECK:
            self._emit("CHECK (")
            if node.HasField("raw_expr"):
                self._visit_node(node.raw_expr)
            self._emit(")")
        elif contype == pb.CONSTR_PRIMARY:
            self._emit("PRIMARY KEY")
        elif contype == pb.CONSTR_UNIQUE:
            self._emit("UNIQUE")
        elif contype == pb.CONSTR_FOREIGN:
            self._emit("REFERENCES ")
            if node.HasField("pktable"):
                self._visit_node(node.pktable)
            if node.pk_attrs:
                self._emit(" (")
                self._emit_inline_list(node.pk_attrs, visit=self._emit_string_or_visit)
                self._emit(")")
        elif contype == pb.CONSTR_IDENTITY:
            if node.generated_when == "d":
                self._emit("GENERATED BY DEFAULT AS IDENTITY")
            else:
                self._emit("GENERATED ALWAYS AS IDENTITY")
        else:
            # Fallback for other constraint types
            pass

    def _visit_constraint(self, node: pb.Constraint) -> None:
        """Visit a table-level constraint."""
        if node.conname:
            self._emit(f"CONSTRAINT {node.conname} ")
        contype = node.contype
        if contype in (pb.CONSTR_PRIMARY, pb.CONSTR_UNIQUE):
            kw = "PRIMARY KEY" if contype == pb.CONSTR_PRIMARY else "UNIQUE"
            self._emit(f"{kw} (")
            self._emit_inline_list(node.keys, visit=self._emit_string_or_visit)
            self._emit(")")
        elif contype == pb.CONSTR_CHECK:
            self._emit("CHECK (")
            if node.HasField("raw_expr"):
                self._visit_node(node.raw_expr)
            self._emit(")")
        elif contype == pb.CONSTR_FOREIGN:
            self._emit("FOREIGN KEY (")
            self._emit_inline_list(node.fk_attrs, visit=self._emit_string_or_visit)
            self._emit(") REFERENCES ")
            if node.HasField("pktable"):
                self._visit_node(node.pktable)
            if node.pk_attrs:
                self._emit(" (")
                self._emit_inline_list(node.pk_attrs, visit=self._emit_string_or_visit)
                self._emit(")")
        else:
            text = self._deparse_node(node)
            self._emit(text)

    # ── CREATE INDEX ──────────────────────────────────────────────

    def visit_IndexStmt(self, node: pb.IndexStmt) -> None:
        self._emit("CREATE ")
        if node.unique:
            self._emit("UNIQUE ")
        self._emit("INDEX ")
        if node.concurrent:
            self._emit("CONCURRENTLY ")
        if node.if_not_exists:
            self._emit("IF NOT EXISTS ")
        if node.idxname:
            self._emit(f"{node.idxname} ")
        self._emit("ON ")
        self._visit_node(node.relation)
        if node.access_method and node.access_method != "btree":
            self._emit(f" USING {node.access_method}")
        self._emit(" (")
        self._emit_inline_list(node.index_params)
        self._emit(")")
        if node.HasField("where_clause"):
            self._emit_where(node.where_clause)

    def visit_IndexElem(self, node: pb.IndexElem) -> None:
        if node.name:
            self._emit(node.name)
        elif node.HasField("expr"):
            self._visit_node(node.expr)
        if node.ordering == pb.SORTBY_ASC:
            self._emit(" ASC")
        elif node.ordering == pb.SORTBY_DESC:
            self._emit(" DESC")
        if node.nulls_ordering == pb.SORTBY_NULLS_FIRST:
            self._emit(" NULLS FIRST")
        elif node.nulls_ordering == pb.SORTBY_NULLS_LAST:
            self._emit(" NULLS LAST")

    # ── CREATE VIEW ───────────────────────────────────────────────

    def visit_ViewStmt(self, node: pb.ViewStmt) -> None:
        self._emit("CREATE ")
        if node.replace:
            self._emit("OR REPLACE ")
        self._emit("VIEW ")
        self._visit_node(node.view)
        if node.aliases:
            self._emit(" (")
            self._emit_inline_list(node.aliases, visit=self._emit_string_or_visit)
            self._emit(")")
        self._emit(" AS")
        self._newline()
        self._visit_node(node.query)

    # ── ALTER TABLE ───────────────────────────────────────────────

    def visit_AlterTableStmt(self, node: pb.AlterTableStmt) -> None:
        obj_type = "TABLE"
        if node.objtype == pb.OBJECT_INDEX:
            obj_type = "INDEX"
        elif node.objtype == pb.OBJECT_VIEW:
            obj_type = "VIEW"
        elif node.objtype == pb.OBJECT_SEQUENCE:
            obj_type = "SEQUENCE"

        self._emit(f"ALTER {obj_type} ")
        if node.missing_ok:
            self._emit("IF EXISTS ")
        self._visit_node(node.relation)

        for i, cmd_node in enumerate(node.cmds):
            if i > 0:
                self._emit(",")
            self._newline()
            self._indent()
            cmd = _unwrap_node(cmd_node)
            self._visit_alter_table_cmd(cmd)
            self._dedent()

    def _visit_alter_table_cmd(self, node: pb.AlterTableCmd | object) -> None:
        cmd = cast("pb.AlterTableCmd", node)
        subtype = cmd.subtype
        if subtype == pb.AT_AddColumn:
            self._emit("ADD COLUMN ")
            if cmd.HasField("def"):
                inner = _unwrap_node(getattr(cmd, "def"))
                if isinstance(inner, pb.ColumnDef):
                    self._visit_column_def(inner)
                else:
                    self._visit_node(inner)
            elif cmd.name:
                self._emit(cmd.name)
        elif subtype == pb.AT_DropColumn:
            self._emit(f"DROP COLUMN {cmd.name}")
            if cmd.behavior == pb.DROP_CASCADE:
                self._emit(" CASCADE")
        elif subtype == pb.AT_AlterColumnType:
            self._emit(f"ALTER COLUMN {cmd.name} TYPE ")
            if cmd.HasField("def"):
                inner = _unwrap_node(getattr(cmd, "def"))
                if isinstance(inner, pb.ColumnDef):
                    self._visit_type_name(inner.type_name)
                    if inner.HasField("raw_default"):
                        self._emit(" USING ")
                        self._visit_node(inner.raw_default)
                else:
                    self._visit_node(inner)
        elif subtype == pb.AT_ColumnDefault:
            self._emit(f"ALTER COLUMN {cmd.name}")
            # Has a def field → SET DEFAULT; otherwise DROP DEFAULT
            self._emit(" SET DEFAULT" if cmd.HasField("def") else " DROP DEFAULT")
        elif subtype == pb.AT_SetNotNull:
            self._emit(f"ALTER COLUMN {cmd.name} SET NOT NULL")
        elif subtype == pb.AT_DropNotNull:
            self._emit(f"ALTER COLUMN {cmd.name} DROP NOT NULL")
        elif subtype == pb.AT_AddConstraint:
            self._emit("ADD ")
            if cmd.HasField("def"):
                inner = _unwrap_node(getattr(cmd, "def"))
                if isinstance(inner, pb.Constraint):
                    self._visit_constraint(inner)
                else:
                    self._visit_node(inner)
        else:
            # Fallback: deparse the whole ALTER TABLE statement
            text = self._deparse_node(cmd)
            self._emit(text)

    # ── DROP ──────────────────────────────────────────────────────

    def visit_DropStmt(self, node: pb.DropStmt) -> None:
        obj_type_map = {
            pb.OBJECT_TABLE: "TABLE",
            pb.OBJECT_INDEX: "INDEX",
            pb.OBJECT_VIEW: "VIEW",
            pb.OBJECT_SEQUENCE: "SEQUENCE",
            pb.OBJECT_SCHEMA: "SCHEMA",
            pb.OBJECT_TYPE: "TYPE",
            pb.OBJECT_FUNCTION: "FUNCTION",
            pb.OBJECT_MATVIEW: "MATERIALIZED VIEW",
        }
        obj_type = obj_type_map.get(node.remove_type, "TABLE")
        self._emit(f"DROP {obj_type} ")
        if node.missing_ok:
            self._emit("IF EXISTS ")
        for i, obj_node in enumerate(node.objects):
            if i > 0:
                self._emit(", ")
            inner = _unwrap_node(obj_node)
            if isinstance(inner, pb.List):
                # Multi-part name like schema.table
                parts = [cast("pb.String", _unwrap_node(n)).sval for n in inner.items]
                self._emit(".".join(parts))
            elif isinstance(inner, pb.String):
                self._emit(inner.sval)
            else:
                self._visit_node(obj_node)
        if node.behavior == pb.DROP_CASCADE:
            self._emit(" CASCADE")
        elif node.behavior == pb.DROP_RESTRICT:
            self._emit(" RESTRICT")

    # ── ColumnDef wrapper ─────────────────────────────────────────

    def visit_ColumnDef(self, node: pb.ColumnDef) -> None:
        self._visit_column_def(node)
