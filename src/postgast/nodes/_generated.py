# DO NOT EDIT — generated by scripts/generate_nodes.py
# ruff: noqa: D100,D101,D102,D105,D107,F821,PIE790
#
# Typed AST wrapper classes for all protobuf node types.
# Regenerate with: uv run python scripts/generate_nodes.py

from __future__ import annotations

from typing import TYPE_CHECKING

from postgast.nodes.base import _REGISTRY, AstNode, _wrap, _wrap_list, _wrap_node_optional

if TYPE_CHECKING:
    import postgast.pg_query_pb2 as pg_query_pb2


class A_ArrayExpr(AstNode):
    """Array constructor expression (``ARRAY[...]``)."""

    __slots__ = ()
    _pb: pg_query_pb2.A_ArrayExpr
    __match_args__ = ("elements",)

    @property
    def elements(self) -> list[AstNode]:
        return _wrap_list(self._pb.elements)

    @property
    def location(self) -> int:
        return self._pb.location


class A_Const(AstNode):
    """Constant literal value (string, number, boolean, or NULL)."""

    __slots__ = ()
    _pb: pg_query_pb2.A_Const
    __match_args__ = (
        "isnull",
        "val",
    )

    @property
    def isnull(self) -> bool:
        return self._pb.isnull

    @property
    def location(self) -> int:
        return self._pb.location

    @property
    def val(self) -> AstNode | int | float | bool | str | None:
        which = self._pb.WhichOneof("val")
        if which is None:
            return None
        inner = getattr(self._pb, which)
        return _wrap(inner)


class A_Expr(AstNode):
    """Expression with an operator (e.g. ``a + b``, ``a LIKE b``)."""

    __slots__ = ()
    _pb: pg_query_pb2.A_Expr
    __match_args__ = (
        "kind",
        "name",
        "lexpr",
        "rexpr",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def name(self) -> list[AstNode]:
        return _wrap_list(self._pb.name)

    @property
    def lexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.lexpr)

    @property
    def rexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.rexpr)

    @property
    def location(self) -> int:
        return self._pb.location


class A_Indices(AstNode):
    """Array subscript or slice (e.g. ``[1]`` or ``[1:3]``)."""

    __slots__ = ()
    _pb: pg_query_pb2.A_Indices
    __match_args__ = (
        "is_slice",
        "lidx",
        "uidx",
    )

    @property
    def is_slice(self) -> bool:
        return self._pb.is_slice

    @property
    def lidx(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.lidx)

    @property
    def uidx(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.uidx)


class A_Indirection(AstNode):
    """Indirection chain (field selection or array subscript on a value)."""

    __slots__ = ()
    _pb: pg_query_pb2.A_Indirection
    __match_args__ = (
        "arg",
        "indirection",
    )

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def indirection(self) -> list[AstNode]:
        return _wrap_list(self._pb.indirection)


class A_Star(AstNode):
    """Star wildcard (``*``) in a column reference or target list."""

    __slots__ = ()
    _pb: pg_query_pb2.A_Star
    __match_args__ = ()
    pass


class AccessPriv(AstNode):
    """Privilege name and optional column list in a ``GRANT``/``REVOKE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AccessPriv
    __match_args__ = (
        "priv_name",
        "cols",
    )

    @property
    def priv_name(self) -> str:
        return self._pb.priv_name

    @property
    def cols(self) -> list[AstNode]:
        return _wrap_list(self._pb.cols)


class Aggref(AstNode):
    """Aggregate function call (planner/executor node)."""

    __slots__ = ()
    _pb: pg_query_pb2.Aggref
    __match_args__ = (
        "xpr",
        "aggfnoid",
        "aggtype",
        "aggcollid",
        "inputcollid",
        "aggargtypes",
        "aggdirectargs",
        "args",
        "aggorder",
        "aggdistinct",
        "aggfilter",
        "aggstar",
        "aggvariadic",
        "aggkind",
        "agglevelsup",
        "aggsplit",
        "aggno",
        "aggtransno",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def aggfnoid(self) -> int:
        return self._pb.aggfnoid

    @property
    def aggtype(self) -> int:
        return self._pb.aggtype

    @property
    def aggcollid(self) -> int:
        return self._pb.aggcollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def aggargtypes(self) -> list[AstNode]:
        return _wrap_list(self._pb.aggargtypes)

    @property
    def aggdirectargs(self) -> list[AstNode]:
        return _wrap_list(self._pb.aggdirectargs)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def aggorder(self) -> list[AstNode]:
        return _wrap_list(self._pb.aggorder)

    @property
    def aggdistinct(self) -> list[AstNode]:
        return _wrap_list(self._pb.aggdistinct)

    @property
    def aggfilter(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.aggfilter)

    @property
    def aggstar(self) -> bool:
        return self._pb.aggstar

    @property
    def aggvariadic(self) -> bool:
        return self._pb.aggvariadic

    @property
    def aggkind(self) -> str:
        return self._pb.aggkind

    @property
    def agglevelsup(self) -> int:
        return self._pb.agglevelsup

    @property
    def aggsplit(self) -> int:
        return self._pb.aggsplit

    @property
    def aggno(self) -> int:
        return self._pb.aggno

    @property
    def aggtransno(self) -> int:
        return self._pb.aggtransno

    @property
    def location(self) -> int:
        return self._pb.location


class Alias(AstNode):
    """Alias for a range variable or column (``AS name(col1, col2, …)``)."""

    __slots__ = ()
    _pb: pg_query_pb2.Alias
    __match_args__ = (
        "aliasname",
        "colnames",
    )

    @property
    def aliasname(self) -> str:
        return self._pb.aliasname

    @property
    def colnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.colnames)


class AlterCollationStmt(AstNode):
    """``ALTER COLLATION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterCollationStmt
    __match_args__ = ("collname",)

    @property
    def collname(self) -> list[AstNode]:
        return _wrap_list(self._pb.collname)


class AlterDatabaseRefreshCollStmt(AstNode):
    """``ALTER DATABASE … REFRESH COLLATION VERSION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterDatabaseRefreshCollStmt
    __match_args__ = ("dbname",)

    @property
    def dbname(self) -> str:
        return self._pb.dbname


class AlterDatabaseSetStmt(AstNode):
    """``ALTER DATABASE … SET/RESET`` configuration statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterDatabaseSetStmt
    __match_args__ = (
        "dbname",
        "setstmt",
    )

    @property
    def dbname(self) -> str:
        return self._pb.dbname

    @property
    def setstmt(self) -> VariableSetStmt | None:
        return _REGISTRY["VariableSetStmt"](self._pb.setstmt) if self._pb.HasField("setstmt") else None


class AlterDatabaseStmt(AstNode):
    """``ALTER DATABASE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterDatabaseStmt
    __match_args__ = (
        "dbname",
        "options",
    )

    @property
    def dbname(self) -> str:
        return self._pb.dbname

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterDefaultPrivilegesStmt(AstNode):
    """``ALTER DEFAULT PRIVILEGES`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterDefaultPrivilegesStmt
    __match_args__ = (
        "options",
        "action",
    )

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def action(self) -> GrantStmt | None:
        return _REGISTRY["GrantStmt"](self._pb.action) if self._pb.HasField("action") else None


class AlterDomainStmt(AstNode):
    """``ALTER DOMAIN`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterDomainStmt
    __match_args__ = (
        "subtype",
        "type_name",
        "name",
        "def_",
        "behavior",
        "missing_ok",
    )

    @property
    def subtype(self) -> str:
        return self._pb.subtype

    @property
    def type_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.type_name)

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def def_(self) -> AstNode | None:
        return _wrap_node_optional(getattr(self._pb, "def"))

    @property
    def behavior(self) -> int:
        return self._pb.behavior

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class AlterEnumStmt(AstNode):
    """``ALTER TYPE … ADD/RENAME VALUE`` for enum types."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterEnumStmt
    __match_args__ = (
        "type_name",
        "old_val",
        "new_val",
        "new_val_neighbor",
        "new_val_is_after",
        "skip_if_new_val_exists",
    )

    @property
    def type_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.type_name)

    @property
    def old_val(self) -> str:
        return self._pb.old_val

    @property
    def new_val(self) -> str:
        return self._pb.new_val

    @property
    def new_val_neighbor(self) -> str:
        return self._pb.new_val_neighbor

    @property
    def new_val_is_after(self) -> bool:
        return self._pb.new_val_is_after

    @property
    def skip_if_new_val_exists(self) -> bool:
        return self._pb.skip_if_new_val_exists


class AlterEventTrigStmt(AstNode):
    """``ALTER EVENT TRIGGER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterEventTrigStmt
    __match_args__ = (
        "trigname",
        "tgenabled",
    )

    @property
    def trigname(self) -> str:
        return self._pb.trigname

    @property
    def tgenabled(self) -> str:
        return self._pb.tgenabled


class AlterExtensionContentsStmt(AstNode):
    """``ALTER EXTENSION … ADD/DROP`` object statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterExtensionContentsStmt
    __match_args__ = (
        "extname",
        "action",
        "objtype",
        "object",
    )

    @property
    def extname(self) -> str:
        return self._pb.extname

    @property
    def action(self) -> int:
        return self._pb.action

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)


class AlterExtensionStmt(AstNode):
    """``ALTER EXTENSION … UPDATE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterExtensionStmt
    __match_args__ = (
        "extname",
        "options",
    )

    @property
    def extname(self) -> str:
        return self._pb.extname

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterFdwStmt(AstNode):
    """``ALTER FOREIGN DATA WRAPPER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterFdwStmt
    __match_args__ = (
        "fdwname",
        "func_options",
        "options",
    )

    @property
    def fdwname(self) -> str:
        return self._pb.fdwname

    @property
    def func_options(self) -> list[AstNode]:
        return _wrap_list(self._pb.func_options)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterForeignServerStmt(AstNode):
    """``ALTER SERVER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterForeignServerStmt
    __match_args__ = (
        "servername",
        "version",
        "options",
        "has_version",
    )

    @property
    def servername(self) -> str:
        return self._pb.servername

    @property
    def version(self) -> str:
        return self._pb.version

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def has_version(self) -> bool:
        return self._pb.has_version


class AlterFunctionStmt(AstNode):
    """``ALTER FUNCTION/PROCEDURE/ROUTINE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterFunctionStmt
    __match_args__ = (
        "objtype",
        "func",
        "actions",
    )

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def func(self) -> ObjectWithArgs | None:
        return _REGISTRY["ObjectWithArgs"](self._pb.func) if self._pb.HasField("func") else None

    @property
    def actions(self) -> list[AstNode]:
        return _wrap_list(self._pb.actions)


class AlterObjectDependsStmt(AstNode):
    """``ALTER … DEPENDS ON EXTENSION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterObjectDependsStmt
    __match_args__ = (
        "object_type",
        "relation",
        "object",
        "extname",
        "remove",
    )

    @property
    def object_type(self) -> int:
        return self._pb.object_type

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)

    @property
    def extname(self) -> String | None:
        return _REGISTRY["String"](self._pb.extname) if self._pb.HasField("extname") else None

    @property
    def remove(self) -> bool:
        return self._pb.remove


class AlterObjectSchemaStmt(AstNode):
    """``ALTER … SET SCHEMA`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterObjectSchemaStmt
    __match_args__ = (
        "object_type",
        "relation",
        "object",
        "newschema",
        "missing_ok",
    )

    @property
    def object_type(self) -> int:
        return self._pb.object_type

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)

    @property
    def newschema(self) -> str:
        return self._pb.newschema

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class AlterOpFamilyStmt(AstNode):
    """``ALTER OPERATOR FAMILY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterOpFamilyStmt
    __match_args__ = (
        "opfamilyname",
        "amname",
        "is_drop",
        "items",
    )

    @property
    def opfamilyname(self) -> list[AstNode]:
        return _wrap_list(self._pb.opfamilyname)

    @property
    def amname(self) -> str:
        return self._pb.amname

    @property
    def is_drop(self) -> bool:
        return self._pb.is_drop

    @property
    def items(self) -> list[AstNode]:
        return _wrap_list(self._pb.items)


class AlterOperatorStmt(AstNode):
    """``ALTER OPERATOR`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterOperatorStmt
    __match_args__ = (
        "opername",
        "options",
    )

    @property
    def opername(self) -> ObjectWithArgs | None:
        return _REGISTRY["ObjectWithArgs"](self._pb.opername) if self._pb.HasField("opername") else None

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterOwnerStmt(AstNode):
    """``ALTER … OWNER TO`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterOwnerStmt
    __match_args__ = (
        "object_type",
        "relation",
        "object",
        "newowner",
    )

    @property
    def object_type(self) -> int:
        return self._pb.object_type

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)

    @property
    def newowner(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.newowner) if self._pb.HasField("newowner") else None


class AlterPolicyStmt(AstNode):
    """``ALTER POLICY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterPolicyStmt
    __match_args__ = (
        "policy_name",
        "table",
        "roles",
        "qual",
        "with_check",
    )

    @property
    def policy_name(self) -> str:
        return self._pb.policy_name

    @property
    def table(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.table) if self._pb.HasField("table") else None

    @property
    def roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.roles)

    @property
    def qual(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.qual)

    @property
    def with_check(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.with_check)


class AlterPublicationStmt(AstNode):
    """``ALTER PUBLICATION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterPublicationStmt
    __match_args__ = (
        "pubname",
        "options",
        "pubobjects",
        "for_all_tables",
        "action",
    )

    @property
    def pubname(self) -> str:
        return self._pb.pubname

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def pubobjects(self) -> list[AstNode]:
        return _wrap_list(self._pb.pubobjects)

    @property
    def for_all_tables(self) -> bool:
        return self._pb.for_all_tables

    @property
    def action(self) -> int:
        return self._pb.action


class AlterRoleSetStmt(AstNode):
    """``ALTER ROLE … SET/RESET`` configuration statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterRoleSetStmt
    __match_args__ = (
        "role",
        "database",
        "setstmt",
    )

    @property
    def role(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.role) if self._pb.HasField("role") else None

    @property
    def database(self) -> str:
        return self._pb.database

    @property
    def setstmt(self) -> VariableSetStmt | None:
        return _REGISTRY["VariableSetStmt"](self._pb.setstmt) if self._pb.HasField("setstmt") else None


class AlterRoleStmt(AstNode):
    """``ALTER ROLE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterRoleStmt
    __match_args__ = (
        "role",
        "options",
        "action",
    )

    @property
    def role(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.role) if self._pb.HasField("role") else None

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def action(self) -> int:
        return self._pb.action


class AlterSeqStmt(AstNode):
    """``ALTER SEQUENCE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterSeqStmt
    __match_args__ = (
        "sequence",
        "options",
        "for_identity",
        "missing_ok",
    )

    @property
    def sequence(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.sequence) if self._pb.HasField("sequence") else None

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def for_identity(self) -> bool:
        return self._pb.for_identity

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class AlterStatsStmt(AstNode):
    """``ALTER STATISTICS`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterStatsStmt
    __match_args__ = (
        "defnames",
        "stxstattarget",
        "missing_ok",
    )

    @property
    def defnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.defnames)

    @property
    def stxstattarget(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.stxstattarget)

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class AlterSubscriptionStmt(AstNode):
    """``ALTER SUBSCRIPTION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterSubscriptionStmt
    __match_args__ = (
        "kind",
        "subname",
        "conninfo",
        "publication",
        "options",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def subname(self) -> str:
        return self._pb.subname

    @property
    def conninfo(self) -> str:
        return self._pb.conninfo

    @property
    def publication(self) -> list[AstNode]:
        return _wrap_list(self._pb.publication)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterSystemStmt(AstNode):
    """``ALTER SYSTEM SET/RESET`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterSystemStmt
    __match_args__ = ("setstmt",)

    @property
    def setstmt(self) -> VariableSetStmt | None:
        return _REGISTRY["VariableSetStmt"](self._pb.setstmt) if self._pb.HasField("setstmt") else None


class AlterTSConfigurationStmt(AstNode):
    """``ALTER TEXT SEARCH CONFIGURATION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTSConfigurationStmt
    __match_args__ = (
        "kind",
        "cfgname",
        "tokentype",
        "dicts",
        "override",
        "replace",
        "missing_ok",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def cfgname(self) -> list[AstNode]:
        return _wrap_list(self._pb.cfgname)

    @property
    def tokentype(self) -> list[AstNode]:
        return _wrap_list(self._pb.tokentype)

    @property
    def dicts(self) -> list[AstNode]:
        return _wrap_list(self._pb.dicts)

    @property
    def override(self) -> bool:
        return self._pb.override

    @property
    def replace(self) -> bool:
        return self._pb.replace

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class AlterTSDictionaryStmt(AstNode):
    """``ALTER TEXT SEARCH DICTIONARY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTSDictionaryStmt
    __match_args__ = (
        "dictname",
        "options",
    )

    @property
    def dictname(self) -> list[AstNode]:
        return _wrap_list(self._pb.dictname)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterTableCmd(AstNode):
    """Single sub-command within an ``ALTER TABLE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTableCmd
    __match_args__ = (
        "subtype",
        "name",
        "num",
        "newowner",
        "def_",
        "behavior",
        "missing_ok",
        "recurse",
    )

    @property
    def subtype(self) -> int:
        return self._pb.subtype

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def num(self) -> int:
        return self._pb.num

    @property
    def newowner(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.newowner) if self._pb.HasField("newowner") else None

    @property
    def def_(self) -> AstNode | None:
        return _wrap_node_optional(getattr(self._pb, "def"))

    @property
    def behavior(self) -> int:
        return self._pb.behavior

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok

    @property
    def recurse(self) -> bool:
        return self._pb.recurse


class AlterTableMoveAllStmt(AstNode):
    """``ALTER TABLE ALL IN TABLESPACE … SET TABLESPACE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTableMoveAllStmt
    __match_args__ = (
        "orig_tablespacename",
        "objtype",
        "roles",
        "new_tablespacename",
        "nowait",
    )

    @property
    def orig_tablespacename(self) -> str:
        return self._pb.orig_tablespacename

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.roles)

    @property
    def new_tablespacename(self) -> str:
        return self._pb.new_tablespacename

    @property
    def nowait(self) -> bool:
        return self._pb.nowait


class AlterTableSpaceOptionsStmt(AstNode):
    """``ALTER TABLESPACE … SET/RESET`` options statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTableSpaceOptionsStmt
    __match_args__ = (
        "tablespacename",
        "options",
        "is_reset",
    )

    @property
    def tablespacename(self) -> str:
        return self._pb.tablespacename

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def is_reset(self) -> bool:
        return self._pb.is_reset


class AlterTableStmt(AstNode):
    """``ALTER TABLE`` statement (contains a list of ``AlterTableCmd``)."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTableStmt
    __match_args__ = (
        "relation",
        "cmds",
        "objtype",
        "missing_ok",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def cmds(self) -> list[AstNode]:
        return _wrap_list(self._pb.cmds)

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class AlterTypeStmt(AstNode):
    """``ALTER TYPE … SET/RESET`` attribute statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterTypeStmt
    __match_args__ = (
        "type_name",
        "options",
    )

    @property
    def type_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.type_name)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlterUserMappingStmt(AstNode):
    """``ALTER USER MAPPING`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.AlterUserMappingStmt
    __match_args__ = (
        "user",
        "servername",
        "options",
    )

    @property
    def user(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.user) if self._pb.HasField("user") else None

    @property
    def servername(self) -> str:
        return self._pb.servername

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class AlternativeSubPlan(AstNode):
    """Alternative sub-plan list (planner node, not produced by parser)."""

    __slots__ = ()
    _pb: pg_query_pb2.AlternativeSubPlan
    __match_args__ = (
        "xpr",
        "subplans",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def subplans(self) -> list[AstNode]:
        return _wrap_list(self._pb.subplans)


class ArrayCoerceExpr(AstNode):
    """Array element-by-element coercion expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.ArrayCoerceExpr
    __match_args__ = (
        "xpr",
        "arg",
        "elemexpr",
        "resulttype",
        "resulttypmod",
        "resultcollid",
        "coerceformat",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def elemexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.elemexpr)

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype

    @property
    def resulttypmod(self) -> int:
        return self._pb.resulttypmod

    @property
    def resultcollid(self) -> int:
        return self._pb.resultcollid

    @property
    def coerceformat(self) -> int:
        return self._pb.coerceformat

    @property
    def location(self) -> int:
        return self._pb.location


class ArrayExpr(AstNode):
    """Array constructor expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.ArrayExpr
    __match_args__ = (
        "xpr",
        "array_typeid",
        "array_collid",
        "element_typeid",
        "elements",
        "multidims",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def array_typeid(self) -> int:
        return self._pb.array_typeid

    @property
    def array_collid(self) -> int:
        return self._pb.array_collid

    @property
    def element_typeid(self) -> int:
        return self._pb.element_typeid

    @property
    def elements(self) -> list[AstNode]:
        return _wrap_list(self._pb.elements)

    @property
    def multidims(self) -> bool:
        return self._pb.multidims

    @property
    def location(self) -> int:
        return self._pb.location


class BitString(AstNode):
    """Bit-string constant value (e.g. ``B'101'``)."""

    __slots__ = ()
    _pb: pg_query_pb2.BitString
    __match_args__ = ("bsval",)

    @property
    def bsval(self) -> str:
        return self._pb.bsval


class BoolExpr(AstNode):
    """Boolean combination expression (``AND``, ``OR``, ``NOT``)."""

    __slots__ = ()
    _pb: pg_query_pb2.BoolExpr
    __match_args__ = (
        "xpr",
        "boolop",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def boolop(self) -> int:
        return self._pb.boolop

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class Boolean(AstNode):
    """Boolean constant value (``TRUE`` or ``FALSE``)."""

    __slots__ = ()
    _pb: pg_query_pb2.Boolean
    __match_args__ = ("boolval",)

    @property
    def boolval(self) -> bool:
        return self._pb.boolval


class BooleanTest(AstNode):
    """``IS [NOT] TRUE/FALSE/UNKNOWN`` test expression."""

    __slots__ = ()
    _pb: pg_query_pb2.BooleanTest
    __match_args__ = (
        "xpr",
        "arg",
        "booltesttype",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def booltesttype(self) -> int:
        return self._pb.booltesttype

    @property
    def location(self) -> int:
        return self._pb.location


class CTECycleClause(AstNode):
    """``CYCLE`` clause in a recursive common table expression."""

    __slots__ = ()
    _pb: pg_query_pb2.CTECycleClause
    __match_args__ = (
        "cycle_col_list",
        "cycle_mark_column",
        "cycle_mark_value",
        "cycle_mark_default",
        "cycle_path_column",
        "cycle_mark_type",
        "cycle_mark_typmod",
        "cycle_mark_collation",
        "cycle_mark_neop",
    )

    @property
    def cycle_col_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.cycle_col_list)

    @property
    def cycle_mark_column(self) -> str:
        return self._pb.cycle_mark_column

    @property
    def cycle_mark_value(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.cycle_mark_value)

    @property
    def cycle_mark_default(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.cycle_mark_default)

    @property
    def cycle_path_column(self) -> str:
        return self._pb.cycle_path_column

    @property
    def location(self) -> int:
        return self._pb.location

    @property
    def cycle_mark_type(self) -> int:
        return self._pb.cycle_mark_type

    @property
    def cycle_mark_typmod(self) -> int:
        return self._pb.cycle_mark_typmod

    @property
    def cycle_mark_collation(self) -> int:
        return self._pb.cycle_mark_collation

    @property
    def cycle_mark_neop(self) -> int:
        return self._pb.cycle_mark_neop


class CTESearchClause(AstNode):
    """``SEARCH`` clause in a recursive common table expression."""

    __slots__ = ()
    _pb: pg_query_pb2.CTESearchClause
    __match_args__ = (
        "search_col_list",
        "search_breadth_first",
        "search_seq_column",
    )

    @property
    def search_col_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.search_col_list)

    @property
    def search_breadth_first(self) -> bool:
        return self._pb.search_breadth_first

    @property
    def search_seq_column(self) -> str:
        return self._pb.search_seq_column

    @property
    def location(self) -> int:
        return self._pb.location


class CallContext(AstNode):
    """Context information for a ``CALL`` statement (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.CallContext
    __match_args__ = ("atomic",)

    @property
    def atomic(self) -> bool:
        return self._pb.atomic


class CallStmt(AstNode):
    """``CALL`` statement for invoking a procedure."""

    __slots__ = ()
    _pb: pg_query_pb2.CallStmt
    __match_args__ = (
        "funccall",
        "funcexpr",
        "outargs",
    )

    @property
    def funccall(self) -> FuncCall | None:
        return _REGISTRY["FuncCall"](self._pb.funccall) if self._pb.HasField("funccall") else None

    @property
    def funcexpr(self) -> FuncExpr | None:
        return _REGISTRY["FuncExpr"](self._pb.funcexpr) if self._pb.HasField("funcexpr") else None

    @property
    def outargs(self) -> list[AstNode]:
        return _wrap_list(self._pb.outargs)


class CaseExpr(AstNode):
    """``CASE WHEN … THEN … ELSE … END`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.CaseExpr
    __match_args__ = (
        "xpr",
        "casetype",
        "casecollid",
        "arg",
        "args",
        "defresult",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def casetype(self) -> int:
        return self._pb.casetype

    @property
    def casecollid(self) -> int:
        return self._pb.casecollid

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def defresult(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.defresult)

    @property
    def location(self) -> int:
        return self._pb.location


class CaseTestExpr(AstNode):
    """Placeholder for the test value inside a ``CASE`` expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.CaseTestExpr
    __match_args__ = (
        "xpr",
        "type_id",
        "type_mod",
        "collation",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def type_id(self) -> int:
        return self._pb.type_id

    @property
    def type_mod(self) -> int:
        return self._pb.type_mod

    @property
    def collation(self) -> int:
        return self._pb.collation


class CaseWhen(AstNode):
    """Single ``WHEN … THEN …`` clause in a ``CASE`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.CaseWhen
    __match_args__ = (
        "xpr",
        "expr",
        "result",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def result(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.result)

    @property
    def location(self) -> int:
        return self._pb.location


class CheckPointStmt(AstNode):
    """``CHECKPOINT`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CheckPointStmt
    __match_args__ = ()
    pass


class ClosePortalStmt(AstNode):
    """``CLOSE`` cursor statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ClosePortalStmt
    __match_args__ = ("portalname",)

    @property
    def portalname(self) -> str:
        return self._pb.portalname


class ClusterStmt(AstNode):
    """``CLUSTER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ClusterStmt
    __match_args__ = (
        "relation",
        "indexname",
        "params",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def indexname(self) -> str:
        return self._pb.indexname

    @property
    def params(self) -> list[AstNode]:
        return _wrap_list(self._pb.params)


class CoalesceExpr(AstNode):
    """``COALESCE(…)`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.CoalesceExpr
    __match_args__ = (
        "xpr",
        "coalescetype",
        "coalescecollid",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def coalescetype(self) -> int:
        return self._pb.coalescetype

    @property
    def coalescecollid(self) -> int:
        return self._pb.coalescecollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class CoerceToDomain(AstNode):
    """Coercion to a domain type with constraint checking (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.CoerceToDomain
    __match_args__ = (
        "xpr",
        "arg",
        "resulttype",
        "resulttypmod",
        "resultcollid",
        "coercionformat",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype

    @property
    def resulttypmod(self) -> int:
        return self._pb.resulttypmod

    @property
    def resultcollid(self) -> int:
        return self._pb.resultcollid

    @property
    def coercionformat(self) -> int:
        return self._pb.coercionformat

    @property
    def location(self) -> int:
        return self._pb.location


class CoerceToDomainValue(AstNode):
    """Placeholder for the value inside a domain check constraint (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.CoerceToDomainValue
    __match_args__ = (
        "xpr",
        "type_id",
        "type_mod",
        "collation",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def type_id(self) -> int:
        return self._pb.type_id

    @property
    def type_mod(self) -> int:
        return self._pb.type_mod

    @property
    def collation(self) -> int:
        return self._pb.collation

    @property
    def location(self) -> int:
        return self._pb.location


class CoerceViaIO(AstNode):
    """Coercion via I/O functions (text output then input, planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.CoerceViaIO
    __match_args__ = (
        "xpr",
        "arg",
        "resulttype",
        "resultcollid",
        "coerceformat",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype

    @property
    def resultcollid(self) -> int:
        return self._pb.resultcollid

    @property
    def coerceformat(self) -> int:
        return self._pb.coerceformat

    @property
    def location(self) -> int:
        return self._pb.location


class CollateClause(AstNode):
    """``COLLATE`` clause attached to an expression or type."""

    __slots__ = ()
    _pb: pg_query_pb2.CollateClause
    __match_args__ = (
        "arg",
        "collname",
    )

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def collname(self) -> list[AstNode]:
        return _wrap_list(self._pb.collname)

    @property
    def location(self) -> int:
        return self._pb.location


class CollateExpr(AstNode):
    """``COLLATE`` expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.CollateExpr
    __match_args__ = (
        "xpr",
        "arg",
        "coll_oid",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def coll_oid(self) -> int:
        return self._pb.coll_oid

    @property
    def location(self) -> int:
        return self._pb.location


class ColumnDef(AstNode):
    """Column definition in ``CREATE TABLE`` or ``ALTER TABLE ADD COLUMN``."""

    __slots__ = ()
    _pb: pg_query_pb2.ColumnDef
    __match_args__ = (
        "colname",
        "type_name",
        "compression",
        "inhcount",
        "is_local",
        "is_not_null",
        "is_from_type",
        "storage",
        "storage_name",
        "raw_default",
        "cooked_default",
        "identity",
        "identity_sequence",
        "generated",
        "coll_clause",
        "coll_oid",
        "constraints",
        "fdwoptions",
    )

    @property
    def colname(self) -> str:
        return self._pb.colname

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def compression(self) -> str:
        return self._pb.compression

    @property
    def inhcount(self) -> int:
        return self._pb.inhcount

    @property
    def is_local(self) -> bool:
        return self._pb.is_local

    @property
    def is_not_null(self) -> bool:
        return self._pb.is_not_null

    @property
    def is_from_type(self) -> bool:
        return self._pb.is_from_type

    @property
    def storage(self) -> str:
        return self._pb.storage

    @property
    def storage_name(self) -> str:
        return self._pb.storage_name

    @property
    def raw_default(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.raw_default)

    @property
    def cooked_default(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.cooked_default)

    @property
    def identity(self) -> str:
        return self._pb.identity

    @property
    def identity_sequence(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.identity_sequence) if self._pb.HasField("identity_sequence") else None

    @property
    def generated(self) -> str:
        return self._pb.generated

    @property
    def coll_clause(self) -> CollateClause | None:
        return _REGISTRY["CollateClause"](self._pb.coll_clause) if self._pb.HasField("coll_clause") else None

    @property
    def coll_oid(self) -> int:
        return self._pb.coll_oid

    @property
    def constraints(self) -> list[AstNode]:
        return _wrap_list(self._pb.constraints)

    @property
    def fdwoptions(self) -> list[AstNode]:
        return _wrap_list(self._pb.fdwoptions)

    @property
    def location(self) -> int:
        return self._pb.location


class ColumnRef(AstNode):
    """Column reference (e.g. ``table.column`` or ``column``)."""

    __slots__ = ()
    _pb: pg_query_pb2.ColumnRef
    __match_args__ = ("fields",)

    @property
    def fields(self) -> list[AstNode]:
        return _wrap_list(self._pb.fields)

    @property
    def location(self) -> int:
        return self._pb.location


class CommentStmt(AstNode):
    """``COMMENT ON`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CommentStmt
    __match_args__ = (
        "objtype",
        "object",
        "comment",
    )

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)

    @property
    def comment(self) -> str:
        return self._pb.comment


class CommonTableExpr(AstNode):
    """Common table expression (CTE) defined in a ``WITH`` clause."""

    __slots__ = ()
    _pb: pg_query_pb2.CommonTableExpr
    __match_args__ = (
        "ctename",
        "aliascolnames",
        "ctematerialized",
        "ctequery",
        "search_clause",
        "cycle_clause",
        "cterecursive",
        "cterefcount",
        "ctecolnames",
        "ctecoltypes",
        "ctecoltypmods",
        "ctecolcollations",
    )

    @property
    def ctename(self) -> str:
        return self._pb.ctename

    @property
    def aliascolnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.aliascolnames)

    @property
    def ctematerialized(self) -> int:
        return self._pb.ctematerialized

    @property
    def ctequery(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.ctequery)

    @property
    def search_clause(self) -> CTESearchClause | None:
        return _REGISTRY["CTESearchClause"](self._pb.search_clause) if self._pb.HasField("search_clause") else None

    @property
    def cycle_clause(self) -> CTECycleClause | None:
        return _REGISTRY["CTECycleClause"](self._pb.cycle_clause) if self._pb.HasField("cycle_clause") else None

    @property
    def location(self) -> int:
        return self._pb.location

    @property
    def cterecursive(self) -> bool:
        return self._pb.cterecursive

    @property
    def cterefcount(self) -> int:
        return self._pb.cterefcount

    @property
    def ctecolnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.ctecolnames)

    @property
    def ctecoltypes(self) -> list[AstNode]:
        return _wrap_list(self._pb.ctecoltypes)

    @property
    def ctecoltypmods(self) -> list[AstNode]:
        return _wrap_list(self._pb.ctecoltypmods)

    @property
    def ctecolcollations(self) -> list[AstNode]:
        return _wrap_list(self._pb.ctecolcollations)


class CompositeTypeStmt(AstNode):
    """``CREATE TYPE … AS (…)`` composite type statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CompositeTypeStmt
    __match_args__ = (
        "typevar",
        "coldeflist",
    )

    @property
    def typevar(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.typevar) if self._pb.HasField("typevar") else None

    @property
    def coldeflist(self) -> list[AstNode]:
        return _wrap_list(self._pb.coldeflist)


class Constraint(AstNode):
    """Column or table constraint (``CHECK``, ``UNIQUE``, ``PRIMARY KEY``, ``FOREIGN KEY``, etc.)."""

    __slots__ = ()
    _pb: pg_query_pb2.Constraint
    __match_args__ = (
        "contype",
        "conname",
        "deferrable",
        "initdeferred",
        "skip_validation",
        "initially_valid",
        "is_no_inherit",
        "raw_expr",
        "cooked_expr",
        "generated_when",
        "inhcount",
        "nulls_not_distinct",
        "keys",
        "including",
        "exclusions",
        "options",
        "indexname",
        "indexspace",
        "reset_default_tblspc",
        "access_method",
        "where_clause",
        "pktable",
        "fk_attrs",
        "pk_attrs",
        "fk_matchtype",
        "fk_upd_action",
        "fk_del_action",
        "fk_del_set_cols",
        "old_conpfeqop",
        "old_pktable_oid",
    )

    @property
    def contype(self) -> int:
        return self._pb.contype

    @property
    def conname(self) -> str:
        return self._pb.conname

    @property
    def deferrable(self) -> bool:
        return self._pb.deferrable

    @property
    def initdeferred(self) -> bool:
        return self._pb.initdeferred

    @property
    def skip_validation(self) -> bool:
        return self._pb.skip_validation

    @property
    def initially_valid(self) -> bool:
        return self._pb.initially_valid

    @property
    def is_no_inherit(self) -> bool:
        return self._pb.is_no_inherit

    @property
    def raw_expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.raw_expr)

    @property
    def cooked_expr(self) -> str:
        return self._pb.cooked_expr

    @property
    def generated_when(self) -> str:
        return self._pb.generated_when

    @property
    def inhcount(self) -> int:
        return self._pb.inhcount

    @property
    def nulls_not_distinct(self) -> bool:
        return self._pb.nulls_not_distinct

    @property
    def keys(self) -> list[AstNode]:
        return _wrap_list(self._pb.keys)

    @property
    def including(self) -> list[AstNode]:
        return _wrap_list(self._pb.including)

    @property
    def exclusions(self) -> list[AstNode]:
        return _wrap_list(self._pb.exclusions)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def indexname(self) -> str:
        return self._pb.indexname

    @property
    def indexspace(self) -> str:
        return self._pb.indexspace

    @property
    def reset_default_tblspc(self) -> bool:
        return self._pb.reset_default_tblspc

    @property
    def access_method(self) -> str:
        return self._pb.access_method

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def pktable(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.pktable) if self._pb.HasField("pktable") else None

    @property
    def fk_attrs(self) -> list[AstNode]:
        return _wrap_list(self._pb.fk_attrs)

    @property
    def pk_attrs(self) -> list[AstNode]:
        return _wrap_list(self._pb.pk_attrs)

    @property
    def fk_matchtype(self) -> str:
        return self._pb.fk_matchtype

    @property
    def fk_upd_action(self) -> str:
        return self._pb.fk_upd_action

    @property
    def fk_del_action(self) -> str:
        return self._pb.fk_del_action

    @property
    def fk_del_set_cols(self) -> list[AstNode]:
        return _wrap_list(self._pb.fk_del_set_cols)

    @property
    def old_conpfeqop(self) -> list[AstNode]:
        return _wrap_list(self._pb.old_conpfeqop)

    @property
    def old_pktable_oid(self) -> int:
        return self._pb.old_pktable_oid

    @property
    def location(self) -> int:
        return self._pb.location


class ConstraintsSetStmt(AstNode):
    """``SET CONSTRAINTS`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ConstraintsSetStmt
    __match_args__ = (
        "constraints",
        "deferred",
    )

    @property
    def constraints(self) -> list[AstNode]:
        return _wrap_list(self._pb.constraints)

    @property
    def deferred(self) -> bool:
        return self._pb.deferred


class ConvertRowtypeExpr(AstNode):
    """Row-type conversion expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.ConvertRowtypeExpr
    __match_args__ = (
        "xpr",
        "arg",
        "resulttype",
        "convertformat",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype

    @property
    def convertformat(self) -> int:
        return self._pb.convertformat

    @property
    def location(self) -> int:
        return self._pb.location


class CopyStmt(AstNode):
    """``COPY`` statement (to/from file or program)."""

    __slots__ = ()
    _pb: pg_query_pb2.CopyStmt
    __match_args__ = (
        "relation",
        "query",
        "attlist",
        "is_from",
        "is_program",
        "filename",
        "options",
        "where_clause",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)

    @property
    def attlist(self) -> list[AstNode]:
        return _wrap_list(self._pb.attlist)

    @property
    def is_from(self) -> bool:
        return self._pb.is_from

    @property
    def is_program(self) -> bool:
        return self._pb.is_program

    @property
    def filename(self) -> str:
        return self._pb.filename

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)


class CreateAmStmt(AstNode):
    """``CREATE ACCESS METHOD`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateAmStmt
    __match_args__ = (
        "amname",
        "handler_name",
        "amtype",
    )

    @property
    def amname(self) -> str:
        return self._pb.amname

    @property
    def handler_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.handler_name)

    @property
    def amtype(self) -> str:
        return self._pb.amtype


class CreateCastStmt(AstNode):
    """``CREATE CAST`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateCastStmt
    __match_args__ = (
        "sourcetype",
        "targettype",
        "func",
        "context",
        "inout",
    )

    @property
    def sourcetype(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.sourcetype) if self._pb.HasField("sourcetype") else None

    @property
    def targettype(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.targettype) if self._pb.HasField("targettype") else None

    @property
    def func(self) -> ObjectWithArgs | None:
        return _REGISTRY["ObjectWithArgs"](self._pb.func) if self._pb.HasField("func") else None

    @property
    def context(self) -> int:
        return self._pb.context

    @property
    def inout(self) -> bool:
        return self._pb.inout


class CreateConversionStmt(AstNode):
    """``CREATE CONVERSION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateConversionStmt
    __match_args__ = (
        "conversion_name",
        "for_encoding_name",
        "to_encoding_name",
        "func_name",
        "def_",
    )

    @property
    def conversion_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.conversion_name)

    @property
    def for_encoding_name(self) -> str:
        return self._pb.for_encoding_name

    @property
    def to_encoding_name(self) -> str:
        return self._pb.to_encoding_name

    @property
    def func_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.func_name)

    @property
    def def_(self) -> bool:
        return getattr(self._pb, "def")


class CreateDomainStmt(AstNode):
    """``CREATE DOMAIN`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateDomainStmt
    __match_args__ = (
        "domainname",
        "type_name",
        "coll_clause",
        "constraints",
    )

    @property
    def domainname(self) -> list[AstNode]:
        return _wrap_list(self._pb.domainname)

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def coll_clause(self) -> CollateClause | None:
        return _REGISTRY["CollateClause"](self._pb.coll_clause) if self._pb.HasField("coll_clause") else None

    @property
    def constraints(self) -> list[AstNode]:
        return _wrap_list(self._pb.constraints)


class CreateEnumStmt(AstNode):
    """``CREATE TYPE … AS ENUM (…)`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateEnumStmt
    __match_args__ = (
        "type_name",
        "vals",
    )

    @property
    def type_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.type_name)

    @property
    def vals(self) -> list[AstNode]:
        return _wrap_list(self._pb.vals)


class CreateEventTrigStmt(AstNode):
    """``CREATE EVENT TRIGGER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateEventTrigStmt
    __match_args__ = (
        "trigname",
        "eventname",
        "whenclause",
        "funcname",
    )

    @property
    def trigname(self) -> str:
        return self._pb.trigname

    @property
    def eventname(self) -> str:
        return self._pb.eventname

    @property
    def whenclause(self) -> list[AstNode]:
        return _wrap_list(self._pb.whenclause)

    @property
    def funcname(self) -> list[AstNode]:
        return _wrap_list(self._pb.funcname)


class CreateExtensionStmt(AstNode):
    """``CREATE EXTENSION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateExtensionStmt
    __match_args__ = (
        "extname",
        "if_not_exists",
        "options",
    )

    @property
    def extname(self) -> str:
        return self._pb.extname

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateFdwStmt(AstNode):
    """``CREATE FOREIGN DATA WRAPPER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateFdwStmt
    __match_args__ = (
        "fdwname",
        "func_options",
        "options",
    )

    @property
    def fdwname(self) -> str:
        return self._pb.fdwname

    @property
    def func_options(self) -> list[AstNode]:
        return _wrap_list(self._pb.func_options)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateForeignServerStmt(AstNode):
    """``CREATE SERVER`` statement for foreign data wrappers."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateForeignServerStmt
    __match_args__ = (
        "servername",
        "servertype",
        "version",
        "fdwname",
        "if_not_exists",
        "options",
    )

    @property
    def servername(self) -> str:
        return self._pb.servername

    @property
    def servertype(self) -> str:
        return self._pb.servertype

    @property
    def version(self) -> str:
        return self._pb.version

    @property
    def fdwname(self) -> str:
        return self._pb.fdwname

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateForeignTableStmt(AstNode):
    """``CREATE FOREIGN TABLE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateForeignTableStmt
    __match_args__ = (
        "base_stmt",
        "servername",
        "options",
    )

    @property
    def base_stmt(self) -> CreateStmt | None:
        return _REGISTRY["CreateStmt"](self._pb.base_stmt) if self._pb.HasField("base_stmt") else None

    @property
    def servername(self) -> str:
        return self._pb.servername

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateFunctionStmt(AstNode):
    """``CREATE FUNCTION/PROCEDURE/ROUTINE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateFunctionStmt
    __match_args__ = (
        "is_procedure",
        "replace",
        "funcname",
        "parameters",
        "return_type",
        "options",
        "sql_body",
    )

    @property
    def is_procedure(self) -> bool:
        return self._pb.is_procedure

    @property
    def replace(self) -> bool:
        return self._pb.replace

    @property
    def funcname(self) -> list[AstNode]:
        return _wrap_list(self._pb.funcname)

    @property
    def parameters(self) -> list[AstNode]:
        return _wrap_list(self._pb.parameters)

    @property
    def return_type(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.return_type) if self._pb.HasField("return_type") else None

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def sql_body(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.sql_body)


class CreateOpClassItem(AstNode):
    """Single item (operator or function) in a ``CREATE OPERATOR CLASS`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateOpClassItem
    __match_args__ = (
        "itemtype",
        "name",
        "number",
        "order_family",
        "class_args",
        "storedtype",
    )

    @property
    def itemtype(self) -> int:
        return self._pb.itemtype

    @property
    def name(self) -> ObjectWithArgs | None:
        return _REGISTRY["ObjectWithArgs"](self._pb.name) if self._pb.HasField("name") else None

    @property
    def number(self) -> int:
        return self._pb.number

    @property
    def order_family(self) -> list[AstNode]:
        return _wrap_list(self._pb.order_family)

    @property
    def class_args(self) -> list[AstNode]:
        return _wrap_list(self._pb.class_args)

    @property
    def storedtype(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.storedtype) if self._pb.HasField("storedtype") else None


class CreateOpClassStmt(AstNode):
    """``CREATE OPERATOR CLASS`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateOpClassStmt
    __match_args__ = (
        "opclassname",
        "opfamilyname",
        "amname",
        "datatype",
        "items",
        "is_default",
    )

    @property
    def opclassname(self) -> list[AstNode]:
        return _wrap_list(self._pb.opclassname)

    @property
    def opfamilyname(self) -> list[AstNode]:
        return _wrap_list(self._pb.opfamilyname)

    @property
    def amname(self) -> str:
        return self._pb.amname

    @property
    def datatype(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.datatype) if self._pb.HasField("datatype") else None

    @property
    def items(self) -> list[AstNode]:
        return _wrap_list(self._pb.items)

    @property
    def is_default(self) -> bool:
        return self._pb.is_default


class CreateOpFamilyStmt(AstNode):
    """``CREATE OPERATOR FAMILY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateOpFamilyStmt
    __match_args__ = (
        "opfamilyname",
        "amname",
    )

    @property
    def opfamilyname(self) -> list[AstNode]:
        return _wrap_list(self._pb.opfamilyname)

    @property
    def amname(self) -> str:
        return self._pb.amname


class CreatePLangStmt(AstNode):
    """``CREATE LANGUAGE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreatePLangStmt
    __match_args__ = (
        "replace",
        "plname",
        "plhandler",
        "plinline",
        "plvalidator",
        "pltrusted",
    )

    @property
    def replace(self) -> bool:
        return self._pb.replace

    @property
    def plname(self) -> str:
        return self._pb.plname

    @property
    def plhandler(self) -> list[AstNode]:
        return _wrap_list(self._pb.plhandler)

    @property
    def plinline(self) -> list[AstNode]:
        return _wrap_list(self._pb.plinline)

    @property
    def plvalidator(self) -> list[AstNode]:
        return _wrap_list(self._pb.plvalidator)

    @property
    def pltrusted(self) -> bool:
        return self._pb.pltrusted


class CreatePolicyStmt(AstNode):
    """``CREATE POLICY`` statement for row-level security."""

    __slots__ = ()
    _pb: pg_query_pb2.CreatePolicyStmt
    __match_args__ = (
        "policy_name",
        "table",
        "cmd_name",
        "permissive",
        "roles",
        "qual",
        "with_check",
    )

    @property
    def policy_name(self) -> str:
        return self._pb.policy_name

    @property
    def table(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.table) if self._pb.HasField("table") else None

    @property
    def cmd_name(self) -> str:
        return self._pb.cmd_name

    @property
    def permissive(self) -> bool:
        return self._pb.permissive

    @property
    def roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.roles)

    @property
    def qual(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.qual)

    @property
    def with_check(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.with_check)


class CreatePublicationStmt(AstNode):
    """``CREATE PUBLICATION`` statement for logical replication."""

    __slots__ = ()
    _pb: pg_query_pb2.CreatePublicationStmt
    __match_args__ = (
        "pubname",
        "options",
        "pubobjects",
        "for_all_tables",
    )

    @property
    def pubname(self) -> str:
        return self._pb.pubname

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def pubobjects(self) -> list[AstNode]:
        return _wrap_list(self._pb.pubobjects)

    @property
    def for_all_tables(self) -> bool:
        return self._pb.for_all_tables


class CreateRangeStmt(AstNode):
    """``CREATE TYPE … AS RANGE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateRangeStmt
    __match_args__ = (
        "type_name",
        "params",
    )

    @property
    def type_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.type_name)

    @property
    def params(self) -> list[AstNode]:
        return _wrap_list(self._pb.params)


class CreateRoleStmt(AstNode):
    """``CREATE ROLE/USER/GROUP`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateRoleStmt
    __match_args__ = (
        "stmt_type",
        "role",
        "options",
    )

    @property
    def stmt_type(self) -> int:
        return self._pb.stmt_type

    @property
    def role(self) -> str:
        return self._pb.role

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateSchemaStmt(AstNode):
    """``CREATE SCHEMA`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateSchemaStmt
    __match_args__ = (
        "schemaname",
        "authrole",
        "schema_elts",
        "if_not_exists",
    )

    @property
    def schemaname(self) -> str:
        return self._pb.schemaname

    @property
    def authrole(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.authrole) if self._pb.HasField("authrole") else None

    @property
    def schema_elts(self) -> list[AstNode]:
        return _wrap_list(self._pb.schema_elts)

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists


class CreateSeqStmt(AstNode):
    """``CREATE SEQUENCE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateSeqStmt
    __match_args__ = (
        "sequence",
        "options",
        "owner_id",
        "for_identity",
        "if_not_exists",
    )

    @property
    def sequence(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.sequence) if self._pb.HasField("sequence") else None

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def owner_id(self) -> int:
        return self._pb.owner_id

    @property
    def for_identity(self) -> bool:
        return self._pb.for_identity

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists


class CreateStatsStmt(AstNode):
    """``CREATE STATISTICS`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateStatsStmt
    __match_args__ = (
        "defnames",
        "stat_types",
        "exprs",
        "relations",
        "stxcomment",
        "transformed",
        "if_not_exists",
    )

    @property
    def defnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.defnames)

    @property
    def stat_types(self) -> list[AstNode]:
        return _wrap_list(self._pb.stat_types)

    @property
    def exprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.exprs)

    @property
    def relations(self) -> list[AstNode]:
        return _wrap_list(self._pb.relations)

    @property
    def stxcomment(self) -> str:
        return self._pb.stxcomment

    @property
    def transformed(self) -> bool:
        return self._pb.transformed

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists


class CreateStmt(AstNode):
    """``CREATE TABLE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateStmt
    __match_args__ = (
        "relation",
        "table_elts",
        "inh_relations",
        "partbound",
        "partspec",
        "of_typename",
        "constraints",
        "options",
        "oncommit",
        "tablespacename",
        "access_method",
        "if_not_exists",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def table_elts(self) -> list[AstNode]:
        return _wrap_list(self._pb.table_elts)

    @property
    def inh_relations(self) -> list[AstNode]:
        return _wrap_list(self._pb.inh_relations)

    @property
    def partbound(self) -> PartitionBoundSpec | None:
        return _REGISTRY["PartitionBoundSpec"](self._pb.partbound) if self._pb.HasField("partbound") else None

    @property
    def partspec(self) -> PartitionSpec | None:
        return _REGISTRY["PartitionSpec"](self._pb.partspec) if self._pb.HasField("partspec") else None

    @property
    def of_typename(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.of_typename) if self._pb.HasField("of_typename") else None

    @property
    def constraints(self) -> list[AstNode]:
        return _wrap_list(self._pb.constraints)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def oncommit(self) -> int:
        return self._pb.oncommit

    @property
    def tablespacename(self) -> str:
        return self._pb.tablespacename

    @property
    def access_method(self) -> str:
        return self._pb.access_method

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists


class CreateSubscriptionStmt(AstNode):
    """``CREATE SUBSCRIPTION`` statement for logical replication."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateSubscriptionStmt
    __match_args__ = (
        "subname",
        "conninfo",
        "publication",
        "options",
    )

    @property
    def subname(self) -> str:
        return self._pb.subname

    @property
    def conninfo(self) -> str:
        return self._pb.conninfo

    @property
    def publication(self) -> list[AstNode]:
        return _wrap_list(self._pb.publication)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateTableAsStmt(AstNode):
    """``CREATE TABLE AS`` or ``SELECT INTO`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateTableAsStmt
    __match_args__ = (
        "query",
        "into",
        "objtype",
        "is_select_into",
        "if_not_exists",
    )

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)

    @property
    def into(self) -> IntoClause | None:
        return _REGISTRY["IntoClause"](self._pb.into) if self._pb.HasField("into") else None

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def is_select_into(self) -> bool:
        return self._pb.is_select_into

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists


class CreateTableSpaceStmt(AstNode):
    """``CREATE TABLESPACE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateTableSpaceStmt
    __match_args__ = (
        "tablespacename",
        "owner",
        "options",
    )

    @property
    def tablespacename(self) -> str:
        return self._pb.tablespacename

    @property
    def owner(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.owner) if self._pb.HasField("owner") else None

    @property
    def location(self) -> str:
        return self._pb.location

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreateTransformStmt(AstNode):
    """``CREATE TRANSFORM`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateTransformStmt
    __match_args__ = (
        "replace",
        "type_name",
        "lang",
        "fromsql",
        "tosql",
    )

    @property
    def replace(self) -> bool:
        return self._pb.replace

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def lang(self) -> str:
        return self._pb.lang

    @property
    def fromsql(self) -> ObjectWithArgs | None:
        return _REGISTRY["ObjectWithArgs"](self._pb.fromsql) if self._pb.HasField("fromsql") else None

    @property
    def tosql(self) -> ObjectWithArgs | None:
        return _REGISTRY["ObjectWithArgs"](self._pb.tosql) if self._pb.HasField("tosql") else None


class CreateTrigStmt(AstNode):
    """``CREATE TRIGGER`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateTrigStmt
    __match_args__ = (
        "replace",
        "isconstraint",
        "trigname",
        "relation",
        "funcname",
        "args",
        "row",
        "timing",
        "events",
        "columns",
        "when_clause",
        "transition_rels",
        "deferrable",
        "initdeferred",
        "constrrel",
    )

    @property
    def replace(self) -> bool:
        return self._pb.replace

    @property
    def isconstraint(self) -> bool:
        return self._pb.isconstraint

    @property
    def trigname(self) -> str:
        return self._pb.trigname

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def funcname(self) -> list[AstNode]:
        return _wrap_list(self._pb.funcname)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def row(self) -> bool:
        return self._pb.row

    @property
    def timing(self) -> int:
        return self._pb.timing

    @property
    def events(self) -> int:
        return self._pb.events

    @property
    def columns(self) -> list[AstNode]:
        return _wrap_list(self._pb.columns)

    @property
    def when_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.when_clause)

    @property
    def transition_rels(self) -> list[AstNode]:
        return _wrap_list(self._pb.transition_rels)

    @property
    def deferrable(self) -> bool:
        return self._pb.deferrable

    @property
    def initdeferred(self) -> bool:
        return self._pb.initdeferred

    @property
    def constrrel(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.constrrel) if self._pb.HasField("constrrel") else None


class CreateUserMappingStmt(AstNode):
    """``CREATE USER MAPPING`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreateUserMappingStmt
    __match_args__ = (
        "user",
        "servername",
        "if_not_exists",
        "options",
    )

    @property
    def user(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.user) if self._pb.HasField("user") else None

    @property
    def servername(self) -> str:
        return self._pb.servername

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CreatedbStmt(AstNode):
    """``CREATE DATABASE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.CreatedbStmt
    __match_args__ = (
        "dbname",
        "options",
    )

    @property
    def dbname(self) -> str:
        return self._pb.dbname

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class CurrentOfExpr(AstNode):
    """``WHERE CURRENT OF cursor`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.CurrentOfExpr
    __match_args__ = (
        "xpr",
        "cvarno",
        "cursor_name",
        "cursor_param",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def cvarno(self) -> int:
        return self._pb.cvarno

    @property
    def cursor_name(self) -> str:
        return self._pb.cursor_name

    @property
    def cursor_param(self) -> int:
        return self._pb.cursor_param


class DeallocateStmt(AstNode):
    """``DEALLOCATE`` prepared statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DeallocateStmt
    __match_args__ = (
        "name",
        "isall",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def isall(self) -> bool:
        return self._pb.isall

    @property
    def location(self) -> int:
        return self._pb.location


class DeclareCursorStmt(AstNode):
    """``DECLARE CURSOR`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DeclareCursorStmt
    __match_args__ = (
        "portalname",
        "options",
        "query",
    )

    @property
    def portalname(self) -> str:
        return self._pb.portalname

    @property
    def options(self) -> int:
        return self._pb.options

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)


class DefElem(AstNode):
    """Generic name/value definition element (used in many option lists)."""

    __slots__ = ()
    _pb: pg_query_pb2.DefElem
    __match_args__ = (
        "defnamespace",
        "defname",
        "arg",
        "defaction",
    )

    @property
    def defnamespace(self) -> str:
        return self._pb.defnamespace

    @property
    def defname(self) -> str:
        return self._pb.defname

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def defaction(self) -> int:
        return self._pb.defaction

    @property
    def location(self) -> int:
        return self._pb.location


class DefineStmt(AstNode):
    """``CREATE AGGREGATE/OPERATOR/TYPE/COLLATION`` definition statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DefineStmt
    __match_args__ = (
        "kind",
        "oldstyle",
        "defnames",
        "args",
        "definition",
        "if_not_exists",
        "replace",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def oldstyle(self) -> bool:
        return self._pb.oldstyle

    @property
    def defnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.defnames)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def definition(self) -> list[AstNode]:
        return _wrap_list(self._pb.definition)

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists

    @property
    def replace(self) -> bool:
        return self._pb.replace


class DeleteStmt(AstNode):
    """``DELETE FROM`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DeleteStmt
    __match_args__ = (
        "relation",
        "using_clause",
        "where_clause",
        "returning_list",
        "with_clause",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def using_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.using_clause)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def returning_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.returning_list)

    @property
    def with_clause(self) -> WithClause | None:
        return _REGISTRY["WithClause"](self._pb.with_clause) if self._pb.HasField("with_clause") else None


class DiscardStmt(AstNode):
    """``DISCARD`` statement (``ALL``, ``PLANS``, ``SEQUENCES``, ``TEMP``)."""

    __slots__ = ()
    _pb: pg_query_pb2.DiscardStmt
    __match_args__ = ("target",)

    @property
    def target(self) -> int:
        return self._pb.target


class DistinctExpr(AstNode):
    """``IS DISTINCT FROM`` expression (planner form of a comparison)."""

    __slots__ = ()
    _pb: pg_query_pb2.DistinctExpr
    __match_args__ = (
        "xpr",
        "opno",
        "opresulttype",
        "opretset",
        "opcollid",
        "inputcollid",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def opno(self) -> int:
        return self._pb.opno

    @property
    def opresulttype(self) -> int:
        return self._pb.opresulttype

    @property
    def opretset(self) -> bool:
        return self._pb.opretset

    @property
    def opcollid(self) -> int:
        return self._pb.opcollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class DoStmt(AstNode):
    """``DO`` anonymous code block statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DoStmt
    __match_args__ = ("args",)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)


class DropOwnedStmt(AstNode):
    """``DROP OWNED BY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DropOwnedStmt
    __match_args__ = (
        "roles",
        "behavior",
    )

    @property
    def roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.roles)

    @property
    def behavior(self) -> int:
        return self._pb.behavior


class DropRoleStmt(AstNode):
    """``DROP ROLE/USER/GROUP`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DropRoleStmt
    __match_args__ = (
        "roles",
        "missing_ok",
    )

    @property
    def roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.roles)

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class DropStmt(AstNode):
    """``DROP`` statement for various object types."""

    __slots__ = ()
    _pb: pg_query_pb2.DropStmt
    __match_args__ = (
        "objects",
        "remove_type",
        "behavior",
        "missing_ok",
        "concurrent",
    )

    @property
    def objects(self) -> list[AstNode]:
        return _wrap_list(self._pb.objects)

    @property
    def remove_type(self) -> int:
        return self._pb.remove_type

    @property
    def behavior(self) -> int:
        return self._pb.behavior

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok

    @property
    def concurrent(self) -> bool:
        return self._pb.concurrent


class DropSubscriptionStmt(AstNode):
    """``DROP SUBSCRIPTION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DropSubscriptionStmt
    __match_args__ = (
        "subname",
        "missing_ok",
        "behavior",
    )

    @property
    def subname(self) -> str:
        return self._pb.subname

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok

    @property
    def behavior(self) -> int:
        return self._pb.behavior


class DropTableSpaceStmt(AstNode):
    """``DROP TABLESPACE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DropTableSpaceStmt
    __match_args__ = (
        "tablespacename",
        "missing_ok",
    )

    @property
    def tablespacename(self) -> str:
        return self._pb.tablespacename

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class DropUserMappingStmt(AstNode):
    """``DROP USER MAPPING`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DropUserMappingStmt
    __match_args__ = (
        "user",
        "servername",
        "missing_ok",
    )

    @property
    def user(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.user) if self._pb.HasField("user") else None

    @property
    def servername(self) -> str:
        return self._pb.servername

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class DropdbStmt(AstNode):
    """``DROP DATABASE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.DropdbStmt
    __match_args__ = (
        "dbname",
        "missing_ok",
        "options",
    )

    @property
    def dbname(self) -> str:
        return self._pb.dbname

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class ExecuteStmt(AstNode):
    """``EXECUTE`` prepared statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ExecuteStmt
    __match_args__ = (
        "name",
        "params",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def params(self) -> list[AstNode]:
        return _wrap_list(self._pb.params)


class ExplainStmt(AstNode):
    """``EXPLAIN`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ExplainStmt
    __match_args__ = (
        "query",
        "options",
    )

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class FetchStmt(AstNode):
    """``FETCH`` or ``MOVE`` cursor statement."""

    __slots__ = ()
    _pb: pg_query_pb2.FetchStmt
    __match_args__ = (
        "direction",
        "how_many",
        "portalname",
        "ismove",
    )

    @property
    def direction(self) -> int:
        return self._pb.direction

    @property
    def how_many(self) -> int:
        return self._pb.how_many

    @property
    def portalname(self) -> str:
        return self._pb.portalname

    @property
    def ismove(self) -> bool:
        return self._pb.ismove


class FieldSelect(AstNode):
    """Field selection from a composite value (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.FieldSelect
    __match_args__ = (
        "xpr",
        "arg",
        "fieldnum",
        "resulttype",
        "resulttypmod",
        "resultcollid",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def fieldnum(self) -> int:
        return self._pb.fieldnum

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype

    @property
    def resulttypmod(self) -> int:
        return self._pb.resulttypmod

    @property
    def resultcollid(self) -> int:
        return self._pb.resultcollid


class FieldStore(AstNode):
    """Field assignment in a composite value update (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.FieldStore
    __match_args__ = (
        "xpr",
        "arg",
        "newvals",
        "fieldnums",
        "resulttype",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def newvals(self) -> list[AstNode]:
        return _wrap_list(self._pb.newvals)

    @property
    def fieldnums(self) -> list[AstNode]:
        return _wrap_list(self._pb.fieldnums)

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype


class Float(AstNode):
    """Floating-point constant value."""

    __slots__ = ()
    _pb: pg_query_pb2.Float
    __match_args__ = ("fval",)

    @property
    def fval(self) -> str:
        return self._pb.fval


class FromExpr(AstNode):
    """``FROM`` clause with an optional ``WHERE`` qualification."""

    __slots__ = ()
    _pb: pg_query_pb2.FromExpr
    __match_args__ = (
        "fromlist",
        "quals",
    )

    @property
    def fromlist(self) -> list[AstNode]:
        return _wrap_list(self._pb.fromlist)

    @property
    def quals(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.quals)


class FuncCall(AstNode):
    """Function call in parsed SQL (e.g. ``func(args)``)."""

    __slots__ = ()
    _pb: pg_query_pb2.FuncCall
    __match_args__ = (
        "funcname",
        "args",
        "agg_order",
        "agg_filter",
        "over",
        "agg_within_group",
        "agg_star",
        "agg_distinct",
        "func_variadic",
        "funcformat",
    )

    @property
    def funcname(self) -> list[AstNode]:
        return _wrap_list(self._pb.funcname)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def agg_order(self) -> list[AstNode]:
        return _wrap_list(self._pb.agg_order)

    @property
    def agg_filter(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.agg_filter)

    @property
    def over(self) -> WindowDef | None:
        return _REGISTRY["WindowDef"](self._pb.over) if self._pb.HasField("over") else None

    @property
    def agg_within_group(self) -> bool:
        return self._pb.agg_within_group

    @property
    def agg_star(self) -> bool:
        return self._pb.agg_star

    @property
    def agg_distinct(self) -> bool:
        return self._pb.agg_distinct

    @property
    def func_variadic(self) -> bool:
        return self._pb.func_variadic

    @property
    def funcformat(self) -> int:
        return self._pb.funcformat

    @property
    def location(self) -> int:
        return self._pb.location


class FuncExpr(AstNode):
    """Function call expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.FuncExpr
    __match_args__ = (
        "xpr",
        "funcid",
        "funcresulttype",
        "funcretset",
        "funcvariadic",
        "funcformat",
        "funccollid",
        "inputcollid",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def funcid(self) -> int:
        return self._pb.funcid

    @property
    def funcresulttype(self) -> int:
        return self._pb.funcresulttype

    @property
    def funcretset(self) -> bool:
        return self._pb.funcretset

    @property
    def funcvariadic(self) -> bool:
        return self._pb.funcvariadic

    @property
    def funcformat(self) -> int:
        return self._pb.funcformat

    @property
    def funccollid(self) -> int:
        return self._pb.funccollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class FunctionParameter(AstNode):
    """Parameter definition in ``CREATE FUNCTION``."""

    __slots__ = ()
    _pb: pg_query_pb2.FunctionParameter
    __match_args__ = (
        "name",
        "arg_type",
        "mode",
        "defexpr",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def arg_type(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.arg_type) if self._pb.HasField("arg_type") else None

    @property
    def mode(self) -> int:
        return self._pb.mode

    @property
    def defexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.defexpr)


class GrantRoleStmt(AstNode):
    """``GRANT/REVOKE`` role membership statement."""

    __slots__ = ()
    _pb: pg_query_pb2.GrantRoleStmt
    __match_args__ = (
        "granted_roles",
        "grantee_roles",
        "is_grant",
        "opt",
        "grantor",
        "behavior",
    )

    @property
    def granted_roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.granted_roles)

    @property
    def grantee_roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.grantee_roles)

    @property
    def is_grant(self) -> bool:
        return self._pb.is_grant

    @property
    def opt(self) -> list[AstNode]:
        return _wrap_list(self._pb.opt)

    @property
    def grantor(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.grantor) if self._pb.HasField("grantor") else None

    @property
    def behavior(self) -> int:
        return self._pb.behavior


class GrantStmt(AstNode):
    """``GRANT/REVOKE`` privileges statement."""

    __slots__ = ()
    _pb: pg_query_pb2.GrantStmt
    __match_args__ = (
        "is_grant",
        "targtype",
        "objtype",
        "objects",
        "privileges",
        "grantees",
        "grant_option",
        "grantor",
        "behavior",
    )

    @property
    def is_grant(self) -> bool:
        return self._pb.is_grant

    @property
    def targtype(self) -> int:
        return self._pb.targtype

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def objects(self) -> list[AstNode]:
        return _wrap_list(self._pb.objects)

    @property
    def privileges(self) -> list[AstNode]:
        return _wrap_list(self._pb.privileges)

    @property
    def grantees(self) -> list[AstNode]:
        return _wrap_list(self._pb.grantees)

    @property
    def grant_option(self) -> bool:
        return self._pb.grant_option

    @property
    def grantor(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.grantor) if self._pb.HasField("grantor") else None

    @property
    def behavior(self) -> int:
        return self._pb.behavior


class GroupingFunc(AstNode):
    """``GROUPING(…)`` function in a query with grouping sets."""

    __slots__ = ()
    _pb: pg_query_pb2.GroupingFunc
    __match_args__ = (
        "xpr",
        "args",
        "refs",
        "agglevelsup",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def refs(self) -> list[AstNode]:
        return _wrap_list(self._pb.refs)

    @property
    def agglevelsup(self) -> int:
        return self._pb.agglevelsup

    @property
    def location(self) -> int:
        return self._pb.location


class GroupingSet(AstNode):
    """``GROUPING SETS``, ``ROLLUP``, or ``CUBE`` clause."""

    __slots__ = ()
    _pb: pg_query_pb2.GroupingSet
    __match_args__ = (
        "kind",
        "content",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def content(self) -> list[AstNode]:
        return _wrap_list(self._pb.content)

    @property
    def location(self) -> int:
        return self._pb.location


class ImportForeignSchemaStmt(AstNode):
    """``IMPORT FOREIGN SCHEMA`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ImportForeignSchemaStmt
    __match_args__ = (
        "server_name",
        "remote_schema",
        "local_schema",
        "list_type",
        "table_list",
        "options",
    )

    @property
    def server_name(self) -> str:
        return self._pb.server_name

    @property
    def remote_schema(self) -> str:
        return self._pb.remote_schema

    @property
    def local_schema(self) -> str:
        return self._pb.local_schema

    @property
    def list_type(self) -> int:
        return self._pb.list_type

    @property
    def table_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.table_list)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)


class IndexElem(AstNode):
    """Single column or expression in an index definition."""

    __slots__ = ()
    _pb: pg_query_pb2.IndexElem
    __match_args__ = (
        "name",
        "expr",
        "indexcolname",
        "collation",
        "opclass",
        "opclassopts",
        "ordering",
        "nulls_ordering",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def indexcolname(self) -> str:
        return self._pb.indexcolname

    @property
    def collation(self) -> list[AstNode]:
        return _wrap_list(self._pb.collation)

    @property
    def opclass(self) -> list[AstNode]:
        return _wrap_list(self._pb.opclass)

    @property
    def opclassopts(self) -> list[AstNode]:
        return _wrap_list(self._pb.opclassopts)

    @property
    def ordering(self) -> int:
        return self._pb.ordering

    @property
    def nulls_ordering(self) -> int:
        return self._pb.nulls_ordering


class IndexStmt(AstNode):
    """``CREATE INDEX`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.IndexStmt
    __match_args__ = (
        "idxname",
        "relation",
        "access_method",
        "table_space",
        "index_params",
        "index_including_params",
        "options",
        "where_clause",
        "exclude_op_names",
        "idxcomment",
        "index_oid",
        "old_number",
        "old_create_subid",
        "old_first_relfilelocator_subid",
        "unique",
        "nulls_not_distinct",
        "primary",
        "isconstraint",
        "deferrable",
        "initdeferred",
        "transformed",
        "concurrent",
        "if_not_exists",
        "reset_default_tblspc",
    )

    @property
    def idxname(self) -> str:
        return self._pb.idxname

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def access_method(self) -> str:
        return self._pb.access_method

    @property
    def table_space(self) -> str:
        return self._pb.table_space

    @property
    def index_params(self) -> list[AstNode]:
        return _wrap_list(self._pb.index_params)

    @property
    def index_including_params(self) -> list[AstNode]:
        return _wrap_list(self._pb.index_including_params)

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def exclude_op_names(self) -> list[AstNode]:
        return _wrap_list(self._pb.exclude_op_names)

    @property
    def idxcomment(self) -> str:
        return self._pb.idxcomment

    @property
    def index_oid(self) -> int:
        return self._pb.index_oid

    @property
    def old_number(self) -> int:
        return self._pb.old_number

    @property
    def old_create_subid(self) -> int:
        return self._pb.old_create_subid

    @property
    def old_first_relfilelocator_subid(self) -> int:
        return self._pb.old_first_relfilelocator_subid

    @property
    def unique(self) -> bool:
        return self._pb.unique

    @property
    def nulls_not_distinct(self) -> bool:
        return self._pb.nulls_not_distinct

    @property
    def primary(self) -> bool:
        return self._pb.primary

    @property
    def isconstraint(self) -> bool:
        return self._pb.isconstraint

    @property
    def deferrable(self) -> bool:
        return self._pb.deferrable

    @property
    def initdeferred(self) -> bool:
        return self._pb.initdeferred

    @property
    def transformed(self) -> bool:
        return self._pb.transformed

    @property
    def concurrent(self) -> bool:
        return self._pb.concurrent

    @property
    def if_not_exists(self) -> bool:
        return self._pb.if_not_exists

    @property
    def reset_default_tblspc(self) -> bool:
        return self._pb.reset_default_tblspc


class InferClause(AstNode):
    """``ON CONFLICT`` inference clause (specifies the conflict target)."""

    __slots__ = ()
    _pb: pg_query_pb2.InferClause
    __match_args__ = (
        "index_elems",
        "where_clause",
        "conname",
    )

    @property
    def index_elems(self) -> list[AstNode]:
        return _wrap_list(self._pb.index_elems)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def conname(self) -> str:
        return self._pb.conname

    @property
    def location(self) -> int:
        return self._pb.location


class InferenceElem(AstNode):
    """Single element of an ``ON CONFLICT`` inference specification (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.InferenceElem
    __match_args__ = (
        "xpr",
        "expr",
        "infercollid",
        "inferopclass",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def infercollid(self) -> int:
        return self._pb.infercollid

    @property
    def inferopclass(self) -> int:
        return self._pb.inferopclass


class InlineCodeBlock(AstNode):
    """Anonymous code block for ``DO`` statement execution (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.InlineCodeBlock
    __match_args__ = (
        "source_text",
        "lang_oid",
        "lang_is_trusted",
        "atomic",
    )

    @property
    def source_text(self) -> str:
        return self._pb.source_text

    @property
    def lang_oid(self) -> int:
        return self._pb.lang_oid

    @property
    def lang_is_trusted(self) -> bool:
        return self._pb.lang_is_trusted

    @property
    def atomic(self) -> bool:
        return self._pb.atomic


class InsertStmt(AstNode):
    """``INSERT INTO`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.InsertStmt
    __match_args__ = (
        "relation",
        "cols",
        "select_stmt",
        "on_conflict_clause",
        "returning_list",
        "with_clause",
        "override",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def cols(self) -> list[AstNode]:
        return _wrap_list(self._pb.cols)

    @property
    def select_stmt(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.select_stmt)

    @property
    def on_conflict_clause(self) -> OnConflictClause | None:
        return (
            _REGISTRY["OnConflictClause"](self._pb.on_conflict_clause)
            if self._pb.HasField("on_conflict_clause")
            else None
        )

    @property
    def returning_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.returning_list)

    @property
    def with_clause(self) -> WithClause | None:
        return _REGISTRY["WithClause"](self._pb.with_clause) if self._pb.HasField("with_clause") else None

    @property
    def override(self) -> int:
        return self._pb.override


class IntList(AstNode):
    """List of integer values (internal protobuf wrapper)."""

    __slots__ = ()
    _pb: pg_query_pb2.IntList
    __match_args__ = ("items",)

    @property
    def items(self) -> list[AstNode]:
        return _wrap_list(self._pb.items)


class Integer(AstNode):
    """Integer constant value."""

    __slots__ = ()
    _pb: pg_query_pb2.Integer
    __match_args__ = ("ival",)

    @property
    def ival(self) -> int:
        return self._pb.ival


class IntoClause(AstNode):
    """``INTO`` clause for ``SELECT INTO`` or ``CREATE TABLE AS``."""

    __slots__ = ()
    _pb: pg_query_pb2.IntoClause
    __match_args__ = (
        "rel",
        "col_names",
        "access_method",
        "options",
        "on_commit",
        "table_space_name",
        "view_query",
        "skip_data",
    )

    @property
    def rel(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.rel) if self._pb.HasField("rel") else None

    @property
    def col_names(self) -> list[AstNode]:
        return _wrap_list(self._pb.col_names)

    @property
    def access_method(self) -> str:
        return self._pb.access_method

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def on_commit(self) -> int:
        return self._pb.on_commit

    @property
    def table_space_name(self) -> str:
        return self._pb.table_space_name

    @property
    def view_query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.view_query)

    @property
    def skip_data(self) -> bool:
        return self._pb.skip_data


class JoinExpr(AstNode):
    """``JOIN`` expression (``INNER``, ``LEFT``, ``RIGHT``, ``FULL``, ``CROSS``)."""

    __slots__ = ()
    _pb: pg_query_pb2.JoinExpr
    __match_args__ = (
        "jointype",
        "is_natural",
        "larg",
        "rarg",
        "using_clause",
        "join_using_alias",
        "quals",
        "alias",
        "rtindex",
    )

    @property
    def jointype(self) -> int:
        return self._pb.jointype

    @property
    def is_natural(self) -> bool:
        return self._pb.is_natural

    @property
    def larg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.larg)

    @property
    def rarg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.rarg)

    @property
    def using_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.using_clause)

    @property
    def join_using_alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.join_using_alias) if self._pb.HasField("join_using_alias") else None

    @property
    def quals(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.quals)

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None

    @property
    def rtindex(self) -> int:
        return self._pb.rtindex


class JsonAggConstructor(AstNode):
    """Common fields for JSON aggregate constructors."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonAggConstructor
    __match_args__ = (
        "output",
        "agg_filter",
        "agg_order",
        "over",
    )

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def agg_filter(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.agg_filter)

    @property
    def agg_order(self) -> list[AstNode]:
        return _wrap_list(self._pb.agg_order)

    @property
    def over(self) -> WindowDef | None:
        return _REGISTRY["WindowDef"](self._pb.over) if self._pb.HasField("over") else None

    @property
    def location(self) -> int:
        return self._pb.location


class JsonArgument(AstNode):
    """Named argument in a JSON constructor (``key : value``)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonArgument
    __match_args__ = (
        "val",
        "name",
    )

    @property
    def val(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.val) if self._pb.HasField("val") else None

    @property
    def name(self) -> str:
        return self._pb.name


class JsonArrayAgg(AstNode):
    """``JSON_ARRAYAGG(…)`` aggregate expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonArrayAgg
    __match_args__ = (
        "constructor",
        "arg",
        "absent_on_null",
    )

    @property
    def constructor(self) -> JsonAggConstructor | None:
        return _REGISTRY["JsonAggConstructor"](self._pb.constructor) if self._pb.HasField("constructor") else None

    @property
    def arg(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.arg) if self._pb.HasField("arg") else None

    @property
    def absent_on_null(self) -> bool:
        return self._pb.absent_on_null


class JsonArrayConstructor(AstNode):
    """``JSON_ARRAY(…)`` constructor expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonArrayConstructor
    __match_args__ = (
        "exprs",
        "output",
        "absent_on_null",
    )

    @property
    def exprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.exprs)

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def absent_on_null(self) -> bool:
        return self._pb.absent_on_null

    @property
    def location(self) -> int:
        return self._pb.location


class JsonArrayQueryConstructor(AstNode):
    """``JSON_ARRAY(subquery)`` constructor expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonArrayQueryConstructor
    __match_args__ = (
        "query",
        "output",
        "format",
        "absent_on_null",
    )

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def format(self) -> JsonFormat | None:
        return _REGISTRY["JsonFormat"](self._pb.format) if self._pb.HasField("format") else None

    @property
    def absent_on_null(self) -> bool:
        return self._pb.absent_on_null

    @property
    def location(self) -> int:
        return self._pb.location


class JsonBehavior(AstNode):
    """``ON ERROR`` or ``ON EMPTY`` behavior clause in JSON functions."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonBehavior
    __match_args__ = (
        "btype",
        "expr",
        "coerce",
    )

    @property
    def btype(self) -> int:
        return self._pb.btype

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def coerce(self) -> bool:
        return self._pb.coerce

    @property
    def location(self) -> int:
        return self._pb.location


class JsonConstructorExpr(AstNode):
    """JSON constructor expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonConstructorExpr
    __match_args__ = (
        "xpr",
        "type",
        "args",
        "func",
        "coercion",
        "returning",
        "absent_on_null",
        "unique",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def type(self) -> int:
        return self._pb.type

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def func(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.func)

    @property
    def coercion(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.coercion)

    @property
    def returning(self) -> JsonReturning | None:
        return _REGISTRY["JsonReturning"](self._pb.returning) if self._pb.HasField("returning") else None

    @property
    def absent_on_null(self) -> bool:
        return self._pb.absent_on_null

    @property
    def unique(self) -> bool:
        return self._pb.unique

    @property
    def location(self) -> int:
        return self._pb.location


class JsonExpr(AstNode):
    """JSON query expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonExpr
    __match_args__ = (
        "xpr",
        "op",
        "column_name",
        "formatted_expr",
        "format",
        "path_spec",
        "returning",
        "passing_names",
        "passing_values",
        "on_empty",
        "on_error",
        "use_io_coercion",
        "use_json_coercion",
        "wrapper",
        "omit_quotes",
        "collation",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def column_name(self) -> str:
        return self._pb.column_name

    @property
    def formatted_expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.formatted_expr)

    @property
    def format(self) -> JsonFormat | None:
        return _REGISTRY["JsonFormat"](self._pb.format) if self._pb.HasField("format") else None

    @property
    def path_spec(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.path_spec)

    @property
    def returning(self) -> JsonReturning | None:
        return _REGISTRY["JsonReturning"](self._pb.returning) if self._pb.HasField("returning") else None

    @property
    def passing_names(self) -> list[AstNode]:
        return _wrap_list(self._pb.passing_names)

    @property
    def passing_values(self) -> list[AstNode]:
        return _wrap_list(self._pb.passing_values)

    @property
    def on_empty(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_empty) if self._pb.HasField("on_empty") else None

    @property
    def on_error(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_error) if self._pb.HasField("on_error") else None

    @property
    def use_io_coercion(self) -> bool:
        return self._pb.use_io_coercion

    @property
    def use_json_coercion(self) -> bool:
        return self._pb.use_json_coercion

    @property
    def wrapper(self) -> int:
        return self._pb.wrapper

    @property
    def omit_quotes(self) -> bool:
        return self._pb.omit_quotes

    @property
    def collation(self) -> int:
        return self._pb.collation

    @property
    def location(self) -> int:
        return self._pb.location


class JsonFormat(AstNode):
    """``FORMAT JSON`` clause specifying JSON encoding."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonFormat
    __match_args__ = (
        "format_type",
        "encoding",
    )

    @property
    def format_type(self) -> int:
        return self._pb.format_type

    @property
    def encoding(self) -> int:
        return self._pb.encoding

    @property
    def location(self) -> int:
        return self._pb.location


class JsonFuncExpr(AstNode):
    """SQL/JSON function expression (``JSON_VALUE``, ``JSON_QUERY``, etc.)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonFuncExpr
    __match_args__ = (
        "op",
        "column_name",
        "context_item",
        "pathspec",
        "passing",
        "output",
        "on_empty",
        "on_error",
        "wrapper",
        "quotes",
    )

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def column_name(self) -> str:
        return self._pb.column_name

    @property
    def context_item(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.context_item) if self._pb.HasField("context_item") else None

    @property
    def pathspec(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.pathspec)

    @property
    def passing(self) -> list[AstNode]:
        return _wrap_list(self._pb.passing)

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def on_empty(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_empty) if self._pb.HasField("on_empty") else None

    @property
    def on_error(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_error) if self._pb.HasField("on_error") else None

    @property
    def wrapper(self) -> int:
        return self._pb.wrapper

    @property
    def quotes(self) -> int:
        return self._pb.quotes

    @property
    def location(self) -> int:
        return self._pb.location


class JsonIsPredicate(AstNode):
    """``IS JSON`` predicate expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonIsPredicate
    __match_args__ = (
        "expr",
        "format",
        "item_type",
        "unique_keys",
    )

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def format(self) -> JsonFormat | None:
        return _REGISTRY["JsonFormat"](self._pb.format) if self._pb.HasField("format") else None

    @property
    def item_type(self) -> int:
        return self._pb.item_type

    @property
    def unique_keys(self) -> bool:
        return self._pb.unique_keys

    @property
    def location(self) -> int:
        return self._pb.location


class JsonKeyValue(AstNode):
    """Single ``key : value`` pair in a JSON object constructor."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonKeyValue
    __match_args__ = (
        "key",
        "value",
    )

    @property
    def key(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.key)

    @property
    def value(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.value) if self._pb.HasField("value") else None


class JsonObjectAgg(AstNode):
    """``JSON_OBJECTAGG(…)`` aggregate expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonObjectAgg
    __match_args__ = (
        "constructor",
        "arg",
        "absent_on_null",
        "unique",
    )

    @property
    def constructor(self) -> JsonAggConstructor | None:
        return _REGISTRY["JsonAggConstructor"](self._pb.constructor) if self._pb.HasField("constructor") else None

    @property
    def arg(self) -> JsonKeyValue | None:
        return _REGISTRY["JsonKeyValue"](self._pb.arg) if self._pb.HasField("arg") else None

    @property
    def absent_on_null(self) -> bool:
        return self._pb.absent_on_null

    @property
    def unique(self) -> bool:
        return self._pb.unique


class JsonObjectConstructor(AstNode):
    """``JSON_OBJECT(…)`` constructor expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonObjectConstructor
    __match_args__ = (
        "exprs",
        "output",
        "absent_on_null",
        "unique",
    )

    @property
    def exprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.exprs)

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def absent_on_null(self) -> bool:
        return self._pb.absent_on_null

    @property
    def unique(self) -> bool:
        return self._pb.unique

    @property
    def location(self) -> int:
        return self._pb.location


class JsonOutput(AstNode):
    """Output type specification for a JSON function."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonOutput
    __match_args__ = (
        "type_name",
        "returning",
    )

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def returning(self) -> JsonReturning | None:
        return _REGISTRY["JsonReturning"](self._pb.returning) if self._pb.HasField("returning") else None


class JsonParseExpr(AstNode):
    """``JSON(…)`` parse expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonParseExpr
    __match_args__ = (
        "expr",
        "output",
        "unique_keys",
    )

    @property
    def expr(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.expr) if self._pb.HasField("expr") else None

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def unique_keys(self) -> bool:
        return self._pb.unique_keys

    @property
    def location(self) -> int:
        return self._pb.location


class JsonReturning(AstNode):
    """``RETURNING`` clause for JSON functions."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonReturning
    __match_args__ = (
        "format",
        "typid",
        "typmod",
    )

    @property
    def format(self) -> JsonFormat | None:
        return _REGISTRY["JsonFormat"](self._pb.format) if self._pb.HasField("format") else None

    @property
    def typid(self) -> int:
        return self._pb.typid

    @property
    def typmod(self) -> int:
        return self._pb.typmod


class JsonScalarExpr(AstNode):
    """``JSON_SCALAR(…)`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonScalarExpr
    __match_args__ = (
        "expr",
        "output",
    )

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def location(self) -> int:
        return self._pb.location


class JsonSerializeExpr(AstNode):
    """``JSON_SERIALIZE(…)`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonSerializeExpr
    __match_args__ = (
        "expr",
        "output",
    )

    @property
    def expr(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.expr) if self._pb.HasField("expr") else None

    @property
    def output(self) -> JsonOutput | None:
        return _REGISTRY["JsonOutput"](self._pb.output) if self._pb.HasField("output") else None

    @property
    def location(self) -> int:
        return self._pb.location


class JsonTable(AstNode):
    """``JSON_TABLE(…)`` expression in a ``FROM`` clause."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonTable
    __match_args__ = (
        "context_item",
        "pathspec",
        "passing",
        "columns",
        "on_error",
        "alias",
        "lateral",
    )

    @property
    def context_item(self) -> JsonValueExpr | None:
        return _REGISTRY["JsonValueExpr"](self._pb.context_item) if self._pb.HasField("context_item") else None

    @property
    def pathspec(self) -> JsonTablePathSpec | None:
        return _REGISTRY["JsonTablePathSpec"](self._pb.pathspec) if self._pb.HasField("pathspec") else None

    @property
    def passing(self) -> list[AstNode]:
        return _wrap_list(self._pb.passing)

    @property
    def columns(self) -> list[AstNode]:
        return _wrap_list(self._pb.columns)

    @property
    def on_error(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_error) if self._pb.HasField("on_error") else None

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None

    @property
    def lateral(self) -> bool:
        return self._pb.lateral

    @property
    def location(self) -> int:
        return self._pb.location


class JsonTableColumn(AstNode):
    """Column definition inside ``JSON_TABLE``."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonTableColumn
    __match_args__ = (
        "coltype",
        "name",
        "type_name",
        "pathspec",
        "format",
        "wrapper",
        "quotes",
        "columns",
        "on_empty",
        "on_error",
    )

    @property
    def coltype(self) -> int:
        return self._pb.coltype

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def pathspec(self) -> JsonTablePathSpec | None:
        return _REGISTRY["JsonTablePathSpec"](self._pb.pathspec) if self._pb.HasField("pathspec") else None

    @property
    def format(self) -> JsonFormat | None:
        return _REGISTRY["JsonFormat"](self._pb.format) if self._pb.HasField("format") else None

    @property
    def wrapper(self) -> int:
        return self._pb.wrapper

    @property
    def quotes(self) -> int:
        return self._pb.quotes

    @property
    def columns(self) -> list[AstNode]:
        return _wrap_list(self._pb.columns)

    @property
    def on_empty(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_empty) if self._pb.HasField("on_empty") else None

    @property
    def on_error(self) -> JsonBehavior | None:
        return _REGISTRY["JsonBehavior"](self._pb.on_error) if self._pb.HasField("on_error") else None

    @property
    def location(self) -> int:
        return self._pb.location


class JsonTablePath(AstNode):
    """Path specification inside ``JSON_TABLE``."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonTablePath
    __match_args__ = ("name",)

    @property
    def name(self) -> str:
        return self._pb.name


class JsonTablePathScan(AstNode):
    """Path scan node inside ``JSON_TABLE`` (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonTablePathScan
    __match_args__ = (
        "plan",
        "path",
        "error_on_error",
        "child",
        "col_min",
        "col_max",
    )

    @property
    def plan(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.plan)

    @property
    def path(self) -> JsonTablePath | None:
        return _REGISTRY["JsonTablePath"](self._pb.path) if self._pb.HasField("path") else None

    @property
    def error_on_error(self) -> bool:
        return self._pb.error_on_error

    @property
    def child(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.child)

    @property
    def col_min(self) -> int:
        return self._pb.col_min

    @property
    def col_max(self) -> int:
        return self._pb.col_max


class JsonTablePathSpec(AstNode):
    """Path specification for ``JSON_TABLE`` with optional name."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonTablePathSpec
    __match_args__ = (
        "string",
        "name",
        "name_location",
    )

    @property
    def string(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.string)

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def name_location(self) -> int:
        return self._pb.name_location

    @property
    def location(self) -> int:
        return self._pb.location


class JsonTableSiblingJoin(AstNode):
    """Sibling join between ``JSON_TABLE`` path scans (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonTableSiblingJoin
    __match_args__ = (
        "plan",
        "lplan",
        "rplan",
    )

    @property
    def plan(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.plan)

    @property
    def lplan(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.lplan)

    @property
    def rplan(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.rplan)


class JsonValueExpr(AstNode):
    """Expression with an associated JSON format (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.JsonValueExpr
    __match_args__ = (
        "raw_expr",
        "formatted_expr",
        "format",
    )

    @property
    def raw_expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.raw_expr)

    @property
    def formatted_expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.formatted_expr)

    @property
    def format(self) -> JsonFormat | None:
        return _REGISTRY["JsonFormat"](self._pb.format) if self._pb.HasField("format") else None


class List(AstNode):
    """Generic list of nodes."""

    __slots__ = ()
    _pb: pg_query_pb2.List
    __match_args__ = ("items",)

    @property
    def items(self) -> list[AstNode]:
        return _wrap_list(self._pb.items)


class ListenStmt(AstNode):
    """``LISTEN`` statement for notification channels."""

    __slots__ = ()
    _pb: pg_query_pb2.ListenStmt
    __match_args__ = ("conditionname",)

    @property
    def conditionname(self) -> str:
        return self._pb.conditionname


class LoadStmt(AstNode):
    """``LOAD`` statement for loading shared libraries."""

    __slots__ = ()
    _pb: pg_query_pb2.LoadStmt
    __match_args__ = ("filename",)

    @property
    def filename(self) -> str:
        return self._pb.filename


class LockStmt(AstNode):
    """``LOCK TABLE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.LockStmt
    __match_args__ = (
        "relations",
        "mode",
        "nowait",
    )

    @property
    def relations(self) -> list[AstNode]:
        return _wrap_list(self._pb.relations)

    @property
    def mode(self) -> int:
        return self._pb.mode

    @property
    def nowait(self) -> bool:
        return self._pb.nowait


class LockingClause(AstNode):
    """``FOR UPDATE/SHARE/NO KEY UPDATE/KEY SHARE`` locking clause."""

    __slots__ = ()
    _pb: pg_query_pb2.LockingClause
    __match_args__ = (
        "locked_rels",
        "strength",
        "wait_policy",
    )

    @property
    def locked_rels(self) -> list[AstNode]:
        return _wrap_list(self._pb.locked_rels)

    @property
    def strength(self) -> int:
        return self._pb.strength

    @property
    def wait_policy(self) -> int:
        return self._pb.wait_policy


class MergeAction(AstNode):
    """Single ``WHEN MATCHED/NOT MATCHED`` action in ``MERGE`` (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.MergeAction
    __match_args__ = (
        "match_kind",
        "command_type",
        "override",
        "qual",
        "target_list",
        "update_colnos",
    )

    @property
    def match_kind(self) -> int:
        return self._pb.match_kind

    @property
    def command_type(self) -> int:
        return self._pb.command_type

    @property
    def override(self) -> int:
        return self._pb.override

    @property
    def qual(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.qual)

    @property
    def target_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.target_list)

    @property
    def update_colnos(self) -> list[AstNode]:
        return _wrap_list(self._pb.update_colnos)


class MergeStmt(AstNode):
    """``MERGE INTO`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.MergeStmt
    __match_args__ = (
        "relation",
        "source_relation",
        "join_condition",
        "merge_when_clauses",
        "returning_list",
        "with_clause",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def source_relation(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.source_relation)

    @property
    def join_condition(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.join_condition)

    @property
    def merge_when_clauses(self) -> list[AstNode]:
        return _wrap_list(self._pb.merge_when_clauses)

    @property
    def returning_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.returning_list)

    @property
    def with_clause(self) -> WithClause | None:
        return _REGISTRY["WithClause"](self._pb.with_clause) if self._pb.HasField("with_clause") else None


class MergeSupportFunc(AstNode):
    """``MERGE`` support function reference (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.MergeSupportFunc
    __match_args__ = (
        "xpr",
        "msftype",
        "msfcollid",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def msftype(self) -> int:
        return self._pb.msftype

    @property
    def msfcollid(self) -> int:
        return self._pb.msfcollid

    @property
    def location(self) -> int:
        return self._pb.location


class MergeWhenClause(AstNode):
    """``WHEN MATCHED/NOT MATCHED`` clause in a ``MERGE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.MergeWhenClause
    __match_args__ = (
        "match_kind",
        "command_type",
        "override",
        "condition",
        "target_list",
        "values",
    )

    @property
    def match_kind(self) -> int:
        return self._pb.match_kind

    @property
    def command_type(self) -> int:
        return self._pb.command_type

    @property
    def override(self) -> int:
        return self._pb.override

    @property
    def condition(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.condition)

    @property
    def target_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.target_list)

    @property
    def values(self) -> list[AstNode]:
        return _wrap_list(self._pb.values)


class MinMaxExpr(AstNode):
    """``GREATEST(…)`` or ``LEAST(…)`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.MinMaxExpr
    __match_args__ = (
        "xpr",
        "minmaxtype",
        "minmaxcollid",
        "inputcollid",
        "op",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def minmaxtype(self) -> int:
        return self._pb.minmaxtype

    @property
    def minmaxcollid(self) -> int:
        return self._pb.minmaxcollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class MultiAssignRef(AstNode):
    """Reference to a specific column of a multi-assignment source."""

    __slots__ = ()
    _pb: pg_query_pb2.MultiAssignRef
    __match_args__ = (
        "source",
        "colno",
        "ncolumns",
    )

    @property
    def source(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.source)

    @property
    def colno(self) -> int:
        return self._pb.colno

    @property
    def ncolumns(self) -> int:
        return self._pb.ncolumns


class NamedArgExpr(AstNode):
    """Named argument in a function call (``name => value``)."""

    __slots__ = ()
    _pb: pg_query_pb2.NamedArgExpr
    __match_args__ = (
        "xpr",
        "arg",
        "name",
        "argnumber",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def argnumber(self) -> int:
        return self._pb.argnumber

    @property
    def location(self) -> int:
        return self._pb.location


class NextValueExpr(AstNode):
    """``nextval(sequence)`` expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.NextValueExpr
    __match_args__ = (
        "xpr",
        "seqid",
        "type_id",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def seqid(self) -> int:
        return self._pb.seqid

    @property
    def type_id(self) -> int:
        return self._pb.type_id


class NotifyStmt(AstNode):
    """``NOTIFY`` statement for sending notifications."""

    __slots__ = ()
    _pb: pg_query_pb2.NotifyStmt
    __match_args__ = (
        "conditionname",
        "payload",
    )

    @property
    def conditionname(self) -> str:
        return self._pb.conditionname

    @property
    def payload(self) -> str:
        return self._pb.payload


class NullIfExpr(AstNode):
    """``NULLIF(a, b)`` expression (planner form)."""

    __slots__ = ()
    _pb: pg_query_pb2.NullIfExpr
    __match_args__ = (
        "xpr",
        "opno",
        "opresulttype",
        "opretset",
        "opcollid",
        "inputcollid",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def opno(self) -> int:
        return self._pb.opno

    @property
    def opresulttype(self) -> int:
        return self._pb.opresulttype

    @property
    def opretset(self) -> bool:
        return self._pb.opretset

    @property
    def opcollid(self) -> int:
        return self._pb.opcollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class NullTest(AstNode):
    """``IS [NOT] NULL`` test expression."""

    __slots__ = ()
    _pb: pg_query_pb2.NullTest
    __match_args__ = (
        "xpr",
        "arg",
        "nulltesttype",
        "argisrow",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def nulltesttype(self) -> int:
        return self._pb.nulltesttype

    @property
    def argisrow(self) -> bool:
        return self._pb.argisrow

    @property
    def location(self) -> int:
        return self._pb.location


class ObjectWithArgs(AstNode):
    """Object name with optional argument types (used for functions/operators)."""

    __slots__ = ()
    _pb: pg_query_pb2.ObjectWithArgs
    __match_args__ = (
        "objname",
        "objargs",
        "objfuncargs",
        "args_unspecified",
    )

    @property
    def objname(self) -> list[AstNode]:
        return _wrap_list(self._pb.objname)

    @property
    def objargs(self) -> list[AstNode]:
        return _wrap_list(self._pb.objargs)

    @property
    def objfuncargs(self) -> list[AstNode]:
        return _wrap_list(self._pb.objfuncargs)

    @property
    def args_unspecified(self) -> bool:
        return self._pb.args_unspecified


class OidList(AstNode):
    """List of OID values (internal protobuf wrapper)."""

    __slots__ = ()
    _pb: pg_query_pb2.OidList
    __match_args__ = ("items",)

    @property
    def items(self) -> list[AstNode]:
        return _wrap_list(self._pb.items)


class OnConflictClause(AstNode):
    """``ON CONFLICT`` clause in an ``INSERT`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.OnConflictClause
    __match_args__ = (
        "action",
        "infer",
        "target_list",
        "where_clause",
    )

    @property
    def action(self) -> int:
        return self._pb.action

    @property
    def infer(self) -> InferClause | None:
        return _REGISTRY["InferClause"](self._pb.infer) if self._pb.HasField("infer") else None

    @property
    def target_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.target_list)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def location(self) -> int:
        return self._pb.location


class OnConflictExpr(AstNode):
    """``ON CONFLICT`` expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.OnConflictExpr
    __match_args__ = (
        "action",
        "arbiter_elems",
        "arbiter_where",
        "constraint",
        "on_conflict_set",
        "on_conflict_where",
        "excl_rel_index",
        "excl_rel_tlist",
    )

    @property
    def action(self) -> int:
        return self._pb.action

    @property
    def arbiter_elems(self) -> list[AstNode]:
        return _wrap_list(self._pb.arbiter_elems)

    @property
    def arbiter_where(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arbiter_where)

    @property
    def constraint(self) -> int:
        return self._pb.constraint

    @property
    def on_conflict_set(self) -> list[AstNode]:
        return _wrap_list(self._pb.on_conflict_set)

    @property
    def on_conflict_where(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.on_conflict_where)

    @property
    def excl_rel_index(self) -> int:
        return self._pb.excl_rel_index

    @property
    def excl_rel_tlist(self) -> list[AstNode]:
        return _wrap_list(self._pb.excl_rel_tlist)


class OpExpr(AstNode):
    """Operator expression (planner form of an operator invocation)."""

    __slots__ = ()
    _pb: pg_query_pb2.OpExpr
    __match_args__ = (
        "xpr",
        "opno",
        "opresulttype",
        "opretset",
        "opcollid",
        "inputcollid",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def opno(self) -> int:
        return self._pb.opno

    @property
    def opresulttype(self) -> int:
        return self._pb.opresulttype

    @property
    def opretset(self) -> bool:
        return self._pb.opretset

    @property
    def opcollid(self) -> int:
        return self._pb.opcollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class PLAssignStmt(AstNode):
    """PL/pgSQL assignment statement (``var := expr``)."""

    __slots__ = ()
    _pb: pg_query_pb2.PLAssignStmt
    __match_args__ = (
        "name",
        "indirection",
        "nnames",
        "val",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def indirection(self) -> list[AstNode]:
        return _wrap_list(self._pb.indirection)

    @property
    def nnames(self) -> int:
        return self._pb.nnames

    @property
    def val(self) -> SelectStmt | None:
        return _REGISTRY["SelectStmt"](self._pb.val) if self._pb.HasField("val") else None

    @property
    def location(self) -> int:
        return self._pb.location


class Param(AstNode):
    """Query parameter reference (``$1``, ``$2``, etc., planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.Param
    __match_args__ = (
        "xpr",
        "paramkind",
        "paramid",
        "paramtype",
        "paramtypmod",
        "paramcollid",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def paramkind(self) -> int:
        return self._pb.paramkind

    @property
    def paramid(self) -> int:
        return self._pb.paramid

    @property
    def paramtype(self) -> int:
        return self._pb.paramtype

    @property
    def paramtypmod(self) -> int:
        return self._pb.paramtypmod

    @property
    def paramcollid(self) -> int:
        return self._pb.paramcollid

    @property
    def location(self) -> int:
        return self._pb.location


class ParamRef(AstNode):
    """Parameter reference (``$1``, ``$2``, etc.) in parsed SQL."""

    __slots__ = ()
    _pb: pg_query_pb2.ParamRef
    __match_args__ = ("number",)

    @property
    def number(self) -> int:
        return self._pb.number

    @property
    def location(self) -> int:
        return self._pb.location


class ParseResult(AstNode):
    """Top-level result of parsing SQL text (contains a list of statements)."""

    __slots__ = ()
    _pb: pg_query_pb2.ParseResult
    __match_args__ = (
        "version",
        "stmts",
    )

    @property
    def version(self) -> int:
        return self._pb.version

    @property
    def stmts(self) -> list[RawStmt]:
        return [_REGISTRY["RawStmt"](item) for item in self._pb.stmts]


class PartitionBoundSpec(AstNode):
    """Partition bound specification (``FOR VALUES …``)."""

    __slots__ = ()
    _pb: pg_query_pb2.PartitionBoundSpec
    __match_args__ = (
        "strategy",
        "is_default",
        "modulus",
        "remainder",
        "listdatums",
        "lowerdatums",
        "upperdatums",
    )

    @property
    def strategy(self) -> str:
        return self._pb.strategy

    @property
    def is_default(self) -> bool:
        return self._pb.is_default

    @property
    def modulus(self) -> int:
        return self._pb.modulus

    @property
    def remainder(self) -> int:
        return self._pb.remainder

    @property
    def listdatums(self) -> list[AstNode]:
        return _wrap_list(self._pb.listdatums)

    @property
    def lowerdatums(self) -> list[AstNode]:
        return _wrap_list(self._pb.lowerdatums)

    @property
    def upperdatums(self) -> list[AstNode]:
        return _wrap_list(self._pb.upperdatums)

    @property
    def location(self) -> int:
        return self._pb.location


class PartitionCmd(AstNode):
    """Sub-command for ``ALTER TABLE … ATTACH/DETACH PARTITION``."""

    __slots__ = ()
    _pb: pg_query_pb2.PartitionCmd
    __match_args__ = (
        "name",
        "bound",
        "concurrent",
    )

    @property
    def name(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.name) if self._pb.HasField("name") else None

    @property
    def bound(self) -> PartitionBoundSpec | None:
        return _REGISTRY["PartitionBoundSpec"](self._pb.bound) if self._pb.HasField("bound") else None

    @property
    def concurrent(self) -> bool:
        return self._pb.concurrent


class PartitionElem(AstNode):
    """Single column, expression, or collation in a partition key."""

    __slots__ = ()
    _pb: pg_query_pb2.PartitionElem
    __match_args__ = (
        "name",
        "expr",
        "collation",
        "opclass",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def collation(self) -> list[AstNode]:
        return _wrap_list(self._pb.collation)

    @property
    def opclass(self) -> list[AstNode]:
        return _wrap_list(self._pb.opclass)

    @property
    def location(self) -> int:
        return self._pb.location


class PartitionRangeDatum(AstNode):
    """Single boundary value in a range partition bound."""

    __slots__ = ()
    _pb: pg_query_pb2.PartitionRangeDatum
    __match_args__ = (
        "kind",
        "value",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def value(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.value)

    @property
    def location(self) -> int:
        return self._pb.location


class PartitionSpec(AstNode):
    """``PARTITION BY`` specification in ``CREATE TABLE``."""

    __slots__ = ()
    _pb: pg_query_pb2.PartitionSpec
    __match_args__ = (
        "strategy",
        "part_params",
    )

    @property
    def strategy(self) -> int:
        return self._pb.strategy

    @property
    def part_params(self) -> list[AstNode]:
        return _wrap_list(self._pb.part_params)

    @property
    def location(self) -> int:
        return self._pb.location


class PrepareStmt(AstNode):
    """``PREPARE`` statement for creating a prepared statement."""

    __slots__ = ()
    _pb: pg_query_pb2.PrepareStmt
    __match_args__ = (
        "name",
        "argtypes",
        "query",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def argtypes(self) -> list[AstNode]:
        return _wrap_list(self._pb.argtypes)

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)


class PublicationObjSpec(AstNode):
    """Object specification in a ``CREATE/ALTER PUBLICATION`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.PublicationObjSpec
    __match_args__ = (
        "pubobjtype",
        "name",
        "pubtable",
    )

    @property
    def pubobjtype(self) -> int:
        return self._pb.pubobjtype

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def pubtable(self) -> PublicationTable | None:
        return _REGISTRY["PublicationTable"](self._pb.pubtable) if self._pb.HasField("pubtable") else None

    @property
    def location(self) -> int:
        return self._pb.location


class PublicationTable(AstNode):
    """Table specification with optional column/row filter in a publication."""

    __slots__ = ()
    _pb: pg_query_pb2.PublicationTable
    __match_args__ = (
        "relation",
        "where_clause",
        "columns",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def columns(self) -> list[AstNode]:
        return _wrap_list(self._pb.columns)


class Query(AstNode):
    """Fully analyzed query tree (planner/executor node, not produced by raw parser)."""

    __slots__ = ()
    _pb: pg_query_pb2.Query
    __match_args__ = (
        "command_type",
        "query_source",
        "can_set_tag",
        "utility_stmt",
        "result_relation",
        "has_aggs",
        "has_window_funcs",
        "has_target_srfs",
        "has_sub_links",
        "has_distinct_on",
        "has_recursive",
        "has_modifying_cte",
        "has_for_update",
        "has_row_security",
        "is_return",
        "cte_list",
        "rtable",
        "rteperminfos",
        "jointree",
        "merge_action_list",
        "merge_target_relation",
        "merge_join_condition",
        "target_list",
        "override",
        "on_conflict",
        "returning_list",
        "group_clause",
        "group_distinct",
        "grouping_sets",
        "having_qual",
        "window_clause",
        "distinct_clause",
        "sort_clause",
        "limit_offset",
        "limit_count",
        "limit_option",
        "row_marks",
        "set_operations",
        "constraint_deps",
        "with_check_options",
    )

    @property
    def command_type(self) -> int:
        return self._pb.command_type

    @property
    def query_source(self) -> int:
        return self._pb.query_source

    @property
    def can_set_tag(self) -> bool:
        return self._pb.can_set_tag

    @property
    def utility_stmt(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.utility_stmt)

    @property
    def result_relation(self) -> int:
        return self._pb.result_relation

    @property
    def has_aggs(self) -> bool:
        return self._pb.has_aggs

    @property
    def has_window_funcs(self) -> bool:
        return self._pb.has_window_funcs

    @property
    def has_target_srfs(self) -> bool:
        return self._pb.has_target_srfs

    @property
    def has_sub_links(self) -> bool:
        return self._pb.has_sub_links

    @property
    def has_distinct_on(self) -> bool:
        return self._pb.has_distinct_on

    @property
    def has_recursive(self) -> bool:
        return self._pb.has_recursive

    @property
    def has_modifying_cte(self) -> bool:
        return self._pb.has_modifying_cte

    @property
    def has_for_update(self) -> bool:
        return self._pb.has_for_update

    @property
    def has_row_security(self) -> bool:
        return self._pb.has_row_security

    @property
    def is_return(self) -> bool:
        return self._pb.is_return

    @property
    def cte_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.cte_list)

    @property
    def rtable(self) -> list[AstNode]:
        return _wrap_list(self._pb.rtable)

    @property
    def rteperminfos(self) -> list[AstNode]:
        return _wrap_list(self._pb.rteperminfos)

    @property
    def jointree(self) -> FromExpr | None:
        return _REGISTRY["FromExpr"](self._pb.jointree) if self._pb.HasField("jointree") else None

    @property
    def merge_action_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.merge_action_list)

    @property
    def merge_target_relation(self) -> int:
        return self._pb.merge_target_relation

    @property
    def merge_join_condition(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.merge_join_condition)

    @property
    def target_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.target_list)

    @property
    def override(self) -> int:
        return self._pb.override

    @property
    def on_conflict(self) -> OnConflictExpr | None:
        return _REGISTRY["OnConflictExpr"](self._pb.on_conflict) if self._pb.HasField("on_conflict") else None

    @property
    def returning_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.returning_list)

    @property
    def group_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.group_clause)

    @property
    def group_distinct(self) -> bool:
        return self._pb.group_distinct

    @property
    def grouping_sets(self) -> list[AstNode]:
        return _wrap_list(self._pb.grouping_sets)

    @property
    def having_qual(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.having_qual)

    @property
    def window_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.window_clause)

    @property
    def distinct_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.distinct_clause)

    @property
    def sort_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.sort_clause)

    @property
    def limit_offset(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.limit_offset)

    @property
    def limit_count(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.limit_count)

    @property
    def limit_option(self) -> int:
        return self._pb.limit_option

    @property
    def row_marks(self) -> list[AstNode]:
        return _wrap_list(self._pb.row_marks)

    @property
    def set_operations(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.set_operations)

    @property
    def constraint_deps(self) -> list[AstNode]:
        return _wrap_list(self._pb.constraint_deps)

    @property
    def with_check_options(self) -> list[AstNode]:
        return _wrap_list(self._pb.with_check_options)

    @property
    def stmt_location(self) -> int:
        return self._pb.stmt_location

    @property
    def stmt_len(self) -> int:
        return self._pb.stmt_len


class RTEPermissionInfo(AstNode):
    """Permission-checking information for a range table entry (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.RTEPermissionInfo
    __match_args__ = (
        "relid",
        "inh",
        "required_perms",
        "check_as_user",
        "selected_cols",
        "inserted_cols",
        "updated_cols",
    )

    @property
    def relid(self) -> int:
        return self._pb.relid

    @property
    def inh(self) -> bool:
        return self._pb.inh

    @property
    def required_perms(self) -> int:
        return self._pb.required_perms

    @property
    def check_as_user(self) -> int:
        return self._pb.check_as_user

    @property
    def selected_cols(self) -> list[int]:
        return list(self._pb.selected_cols)

    @property
    def inserted_cols(self) -> list[int]:
        return list(self._pb.inserted_cols)

    @property
    def updated_cols(self) -> list[int]:
        return list(self._pb.updated_cols)


class RangeFunction(AstNode):
    """Function call in a ``FROM`` clause."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeFunction
    __match_args__ = (
        "lateral",
        "ordinality",
        "is_rowsfrom",
        "functions",
        "alias",
        "coldeflist",
    )

    @property
    def lateral(self) -> bool:
        return self._pb.lateral

    @property
    def ordinality(self) -> bool:
        return self._pb.ordinality

    @property
    def is_rowsfrom(self) -> bool:
        return self._pb.is_rowsfrom

    @property
    def functions(self) -> list[AstNode]:
        return _wrap_list(self._pb.functions)

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None

    @property
    def coldeflist(self) -> list[AstNode]:
        return _wrap_list(self._pb.coldeflist)


class RangeSubselect(AstNode):
    """Sub-``SELECT`` in a ``FROM`` clause."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeSubselect
    __match_args__ = (
        "lateral",
        "subquery",
        "alias",
    )

    @property
    def lateral(self) -> bool:
        return self._pb.lateral

    @property
    def subquery(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.subquery)

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None


class RangeTableFunc(AstNode):
    """``XMLTABLE`` or similar table-valued function in ``FROM``."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeTableFunc
    __match_args__ = (
        "lateral",
        "docexpr",
        "rowexpr",
        "namespaces",
        "columns",
        "alias",
    )

    @property
    def lateral(self) -> bool:
        return self._pb.lateral

    @property
    def docexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.docexpr)

    @property
    def rowexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.rowexpr)

    @property
    def namespaces(self) -> list[AstNode]:
        return _wrap_list(self._pb.namespaces)

    @property
    def columns(self) -> list[AstNode]:
        return _wrap_list(self._pb.columns)

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None

    @property
    def location(self) -> int:
        return self._pb.location


class RangeTableFuncCol(AstNode):
    """Column definition in a ``XMLTABLE``-style function."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeTableFuncCol
    __match_args__ = (
        "colname",
        "type_name",
        "for_ordinality",
        "is_not_null",
        "colexpr",
        "coldefexpr",
    )

    @property
    def colname(self) -> str:
        return self._pb.colname

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def for_ordinality(self) -> bool:
        return self._pb.for_ordinality

    @property
    def is_not_null(self) -> bool:
        return self._pb.is_not_null

    @property
    def colexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.colexpr)

    @property
    def coldefexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.coldefexpr)

    @property
    def location(self) -> int:
        return self._pb.location


class RangeTableSample(AstNode):
    """``TABLESAMPLE`` clause in a ``FROM`` item."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeTableSample
    __match_args__ = (
        "relation",
        "method",
        "args",
        "repeatable",
    )

    @property
    def relation(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.relation)

    @property
    def method(self) -> list[AstNode]:
        return _wrap_list(self._pb.method)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def repeatable(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.repeatable)

    @property
    def location(self) -> int:
        return self._pb.location


class RangeTblEntry(AstNode):
    """Range table entry (planner node representing a ``FROM`` item)."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeTblEntry
    __match_args__ = (
        "alias",
        "eref",
        "rtekind",
        "relid",
        "inh",
        "relkind",
        "rellockmode",
        "perminfoindex",
        "tablesample",
        "subquery",
        "security_barrier",
        "jointype",
        "joinmergedcols",
        "joinaliasvars",
        "joinleftcols",
        "joinrightcols",
        "join_using_alias",
        "functions",
        "funcordinality",
        "tablefunc",
        "values_lists",
        "ctename",
        "ctelevelsup",
        "self_reference",
        "coltypes",
        "coltypmods",
        "colcollations",
        "enrname",
        "enrtuples",
        "lateral",
        "in_from_cl",
        "security_quals",
    )

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None

    @property
    def eref(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.eref) if self._pb.HasField("eref") else None

    @property
    def rtekind(self) -> int:
        return self._pb.rtekind

    @property
    def relid(self) -> int:
        return self._pb.relid

    @property
    def inh(self) -> bool:
        return self._pb.inh

    @property
    def relkind(self) -> str:
        return self._pb.relkind

    @property
    def rellockmode(self) -> int:
        return self._pb.rellockmode

    @property
    def perminfoindex(self) -> int:
        return self._pb.perminfoindex

    @property
    def tablesample(self) -> TableSampleClause | None:
        return _REGISTRY["TableSampleClause"](self._pb.tablesample) if self._pb.HasField("tablesample") else None

    @property
    def subquery(self) -> Query | None:
        return _REGISTRY["Query"](self._pb.subquery) if self._pb.HasField("subquery") else None

    @property
    def security_barrier(self) -> bool:
        return self._pb.security_barrier

    @property
    def jointype(self) -> int:
        return self._pb.jointype

    @property
    def joinmergedcols(self) -> int:
        return self._pb.joinmergedcols

    @property
    def joinaliasvars(self) -> list[AstNode]:
        return _wrap_list(self._pb.joinaliasvars)

    @property
    def joinleftcols(self) -> list[AstNode]:
        return _wrap_list(self._pb.joinleftcols)

    @property
    def joinrightcols(self) -> list[AstNode]:
        return _wrap_list(self._pb.joinrightcols)

    @property
    def join_using_alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.join_using_alias) if self._pb.HasField("join_using_alias") else None

    @property
    def functions(self) -> list[AstNode]:
        return _wrap_list(self._pb.functions)

    @property
    def funcordinality(self) -> bool:
        return self._pb.funcordinality

    @property
    def tablefunc(self) -> TableFunc | None:
        return _REGISTRY["TableFunc"](self._pb.tablefunc) if self._pb.HasField("tablefunc") else None

    @property
    def values_lists(self) -> list[AstNode]:
        return _wrap_list(self._pb.values_lists)

    @property
    def ctename(self) -> str:
        return self._pb.ctename

    @property
    def ctelevelsup(self) -> int:
        return self._pb.ctelevelsup

    @property
    def self_reference(self) -> bool:
        return self._pb.self_reference

    @property
    def coltypes(self) -> list[AstNode]:
        return _wrap_list(self._pb.coltypes)

    @property
    def coltypmods(self) -> list[AstNode]:
        return _wrap_list(self._pb.coltypmods)

    @property
    def colcollations(self) -> list[AstNode]:
        return _wrap_list(self._pb.colcollations)

    @property
    def enrname(self) -> str:
        return self._pb.enrname

    @property
    def enrtuples(self) -> float:
        return self._pb.enrtuples

    @property
    def lateral(self) -> bool:
        return self._pb.lateral

    @property
    def in_from_cl(self) -> bool:
        return self._pb.in_from_cl

    @property
    def security_quals(self) -> list[AstNode]:
        return _wrap_list(self._pb.security_quals)


class RangeTblFunction(AstNode):
    """Function call within a range table entry (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeTblFunction
    __match_args__ = (
        "funcexpr",
        "funccolcount",
        "funccolnames",
        "funccoltypes",
        "funccoltypmods",
        "funccolcollations",
        "funcparams",
    )

    @property
    def funcexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.funcexpr)

    @property
    def funccolcount(self) -> int:
        return self._pb.funccolcount

    @property
    def funccolnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.funccolnames)

    @property
    def funccoltypes(self) -> list[AstNode]:
        return _wrap_list(self._pb.funccoltypes)

    @property
    def funccoltypmods(self) -> list[AstNode]:
        return _wrap_list(self._pb.funccoltypmods)

    @property
    def funccolcollations(self) -> list[AstNode]:
        return _wrap_list(self._pb.funccolcollations)

    @property
    def funcparams(self) -> list[int]:
        return list(self._pb.funcparams)


class RangeTblRef(AstNode):
    """Reference to a range table entry by index (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeTblRef
    __match_args__ = ("rtindex",)

    @property
    def rtindex(self) -> int:
        return self._pb.rtindex


class RangeVar(AstNode):
    """Table or view reference (``schema.table``)."""

    __slots__ = ()
    _pb: pg_query_pb2.RangeVar
    __match_args__ = (
        "catalogname",
        "schemaname",
        "relname",
        "inh",
        "relpersistence",
        "alias",
    )

    @property
    def catalogname(self) -> str:
        return self._pb.catalogname

    @property
    def schemaname(self) -> str:
        return self._pb.schemaname

    @property
    def relname(self) -> str:
        return self._pb.relname

    @property
    def inh(self) -> bool:
        return self._pb.inh

    @property
    def relpersistence(self) -> str:
        return self._pb.relpersistence

    @property
    def alias(self) -> Alias | None:
        return _REGISTRY["Alias"](self._pb.alias) if self._pb.HasField("alias") else None

    @property
    def location(self) -> int:
        return self._pb.location


class RawStmt(AstNode):
    """Raw statement wrapper with statement location information."""

    __slots__ = ()
    _pb: pg_query_pb2.RawStmt
    __match_args__ = ("stmt",)

    @property
    def stmt(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.stmt)

    @property
    def stmt_location(self) -> int:
        return self._pb.stmt_location

    @property
    def stmt_len(self) -> int:
        return self._pb.stmt_len


class ReassignOwnedStmt(AstNode):
    """``REASSIGN OWNED BY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ReassignOwnedStmt
    __match_args__ = (
        "roles",
        "newrole",
    )

    @property
    def roles(self) -> list[AstNode]:
        return _wrap_list(self._pb.roles)

    @property
    def newrole(self) -> RoleSpec | None:
        return _REGISTRY["RoleSpec"](self._pb.newrole) if self._pb.HasField("newrole") else None


class RefreshMatViewStmt(AstNode):
    """``REFRESH MATERIALIZED VIEW`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.RefreshMatViewStmt
    __match_args__ = (
        "concurrent",
        "skip_data",
        "relation",
    )

    @property
    def concurrent(self) -> bool:
        return self._pb.concurrent

    @property
    def skip_data(self) -> bool:
        return self._pb.skip_data

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None


class ReindexStmt(AstNode):
    """``REINDEX`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ReindexStmt
    __match_args__ = (
        "kind",
        "relation",
        "name",
        "params",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def params(self) -> list[AstNode]:
        return _wrap_list(self._pb.params)


class RelabelType(AstNode):
    """Type relabeling (no-op cast, planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.RelabelType
    __match_args__ = (
        "xpr",
        "arg",
        "resulttype",
        "resulttypmod",
        "resultcollid",
        "relabelformat",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def resulttype(self) -> int:
        return self._pb.resulttype

    @property
    def resulttypmod(self) -> int:
        return self._pb.resulttypmod

    @property
    def resultcollid(self) -> int:
        return self._pb.resultcollid

    @property
    def relabelformat(self) -> int:
        return self._pb.relabelformat

    @property
    def location(self) -> int:
        return self._pb.location


class RenameStmt(AstNode):
    """``ALTER … RENAME`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.RenameStmt
    __match_args__ = (
        "rename_type",
        "relation_type",
        "relation",
        "object",
        "subname",
        "newname",
        "behavior",
        "missing_ok",
    )

    @property
    def rename_type(self) -> int:
        return self._pb.rename_type

    @property
    def relation_type(self) -> int:
        return self._pb.relation_type

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)

    @property
    def subname(self) -> str:
        return self._pb.subname

    @property
    def newname(self) -> str:
        return self._pb.newname

    @property
    def behavior(self) -> int:
        return self._pb.behavior

    @property
    def missing_ok(self) -> bool:
        return self._pb.missing_ok


class ReplicaIdentityStmt(AstNode):
    """``ALTER TABLE … REPLICA IDENTITY`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ReplicaIdentityStmt
    __match_args__ = (
        "identity_type",
        "name",
    )

    @property
    def identity_type(self) -> str:
        return self._pb.identity_type

    @property
    def name(self) -> str:
        return self._pb.name


class ResTarget(AstNode):
    """Result target in a ``SELECT`` list, ``INSERT`` column list, or ``UPDATE SET`` clause."""

    __slots__ = ()
    _pb: pg_query_pb2.ResTarget
    __match_args__ = (
        "name",
        "indirection",
        "val",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def indirection(self) -> list[AstNode]:
        return _wrap_list(self._pb.indirection)

    @property
    def val(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.val)

    @property
    def location(self) -> int:
        return self._pb.location


class ReturnStmt(AstNode):
    """``RETURN`` statement (SQL function body)."""

    __slots__ = ()
    _pb: pg_query_pb2.ReturnStmt
    __match_args__ = ("returnval",)

    @property
    def returnval(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.returnval)


class RoleSpec(AstNode):
    """Role specification (role name, ``CURRENT_USER``, ``SESSION_USER``, or ``PUBLIC``)."""

    __slots__ = ()
    _pb: pg_query_pb2.RoleSpec
    __match_args__ = (
        "roletype",
        "rolename",
    )

    @property
    def roletype(self) -> int:
        return self._pb.roletype

    @property
    def rolename(self) -> str:
        return self._pb.rolename

    @property
    def location(self) -> int:
        return self._pb.location


class RowCompareExpr(AstNode):
    """Row-wise comparison expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.RowCompareExpr
    __match_args__ = (
        "xpr",
        "rctype",
        "opnos",
        "opfamilies",
        "inputcollids",
        "largs",
        "rargs",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def rctype(self) -> int:
        return self._pb.rctype

    @property
    def opnos(self) -> list[AstNode]:
        return _wrap_list(self._pb.opnos)

    @property
    def opfamilies(self) -> list[AstNode]:
        return _wrap_list(self._pb.opfamilies)

    @property
    def inputcollids(self) -> list[AstNode]:
        return _wrap_list(self._pb.inputcollids)

    @property
    def largs(self) -> list[AstNode]:
        return _wrap_list(self._pb.largs)

    @property
    def rargs(self) -> list[AstNode]:
        return _wrap_list(self._pb.rargs)


class RowExpr(AstNode):
    """``ROW(…)`` constructor expression."""

    __slots__ = ()
    _pb: pg_query_pb2.RowExpr
    __match_args__ = (
        "xpr",
        "args",
        "row_typeid",
        "row_format",
        "colnames",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def row_typeid(self) -> int:
        return self._pb.row_typeid

    @property
    def row_format(self) -> int:
        return self._pb.row_format

    @property
    def colnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.colnames)

    @property
    def location(self) -> int:
        return self._pb.location


class RowMarkClause(AstNode):
    """Row-mark clause for locking/marking rows in a query plan."""

    __slots__ = ()
    _pb: pg_query_pb2.RowMarkClause
    __match_args__ = (
        "rti",
        "strength",
        "wait_policy",
        "pushed_down",
    )

    @property
    def rti(self) -> int:
        return self._pb.rti

    @property
    def strength(self) -> int:
        return self._pb.strength

    @property
    def wait_policy(self) -> int:
        return self._pb.wait_policy

    @property
    def pushed_down(self) -> bool:
        return self._pb.pushed_down


class RuleStmt(AstNode):
    """``CREATE RULE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.RuleStmt
    __match_args__ = (
        "relation",
        "rulename",
        "where_clause",
        "event",
        "instead",
        "actions",
        "replace",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def rulename(self) -> str:
        return self._pb.rulename

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def event(self) -> int:
        return self._pb.event

    @property
    def instead(self) -> bool:
        return self._pb.instead

    @property
    def actions(self) -> list[AstNode]:
        return _wrap_list(self._pb.actions)

    @property
    def replace(self) -> bool:
        return self._pb.replace


class SQLValueFunction(AstNode):
    """SQL-standard function requiring no arguments (e.g. ``CURRENT_TIMESTAMP``)."""

    __slots__ = ()
    _pb: pg_query_pb2.SQLValueFunction
    __match_args__ = (
        "xpr",
        "op",
        "type",
        "typmod",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def type(self) -> int:
        return self._pb.type

    @property
    def typmod(self) -> int:
        return self._pb.typmod

    @property
    def location(self) -> int:
        return self._pb.location


class ScalarArrayOpExpr(AstNode):
    """Scalar operator applied to an array (``ANY``/``ALL``, planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.ScalarArrayOpExpr
    __match_args__ = (
        "xpr",
        "opno",
        "use_or",
        "inputcollid",
        "args",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def opno(self) -> int:
        return self._pb.opno

    @property
    def use_or(self) -> bool:
        return self._pb.use_or

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def location(self) -> int:
        return self._pb.location


class ScanResult(AstNode):
    """Top-level result of scanning SQL text for tokens."""

    __slots__ = ()
    _pb: pg_query_pb2.ScanResult
    __match_args__ = (
        "version",
        "tokens",
    )

    @property
    def version(self) -> int:
        return self._pb.version

    @property
    def tokens(self) -> list[ScanToken]:
        return [_REGISTRY["ScanToken"](item) for item in self._pb.tokens]


class ScanToken(AstNode):
    """Single token from the SQL scanner."""

    __slots__ = ()
    _pb: pg_query_pb2.ScanToken
    __match_args__ = (
        "start",
        "end",
        "token",
        "keyword_kind",
    )

    @property
    def start(self) -> int:
        return self._pb.start

    @property
    def end(self) -> int:
        return self._pb.end

    @property
    def token(self) -> int:
        return self._pb.token

    @property
    def keyword_kind(self) -> int:
        return self._pb.keyword_kind


class SecLabelStmt(AstNode):
    """``SECURITY LABEL`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.SecLabelStmt
    __match_args__ = (
        "objtype",
        "object",
        "provider",
        "label",
    )

    @property
    def objtype(self) -> int:
        return self._pb.objtype

    @property
    def object(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.object)

    @property
    def provider(self) -> str:
        return self._pb.provider

    @property
    def label(self) -> str:
        return self._pb.label


class SelectStmt(AstNode):
    """``SELECT`` statement (also used for ``VALUES`` and set operations)."""

    __slots__ = ()
    _pb: pg_query_pb2.SelectStmt
    __match_args__ = (
        "distinct_clause",
        "into_clause",
        "target_list",
        "from_clause",
        "where_clause",
        "group_clause",
        "group_distinct",
        "having_clause",
        "window_clause",
        "values_lists",
        "sort_clause",
        "limit_offset",
        "limit_count",
        "limit_option",
        "locking_clause",
        "with_clause",
        "op",
        "all",
        "larg",
        "rarg",
    )

    @property
    def distinct_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.distinct_clause)

    @property
    def into_clause(self) -> IntoClause | None:
        return _REGISTRY["IntoClause"](self._pb.into_clause) if self._pb.HasField("into_clause") else None

    @property
    def target_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.target_list)

    @property
    def from_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.from_clause)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def group_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.group_clause)

    @property
    def group_distinct(self) -> bool:
        return self._pb.group_distinct

    @property
    def having_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.having_clause)

    @property
    def window_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.window_clause)

    @property
    def values_lists(self) -> list[AstNode]:
        return _wrap_list(self._pb.values_lists)

    @property
    def sort_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.sort_clause)

    @property
    def limit_offset(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.limit_offset)

    @property
    def limit_count(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.limit_count)

    @property
    def limit_option(self) -> int:
        return self._pb.limit_option

    @property
    def locking_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.locking_clause)

    @property
    def with_clause(self) -> WithClause | None:
        return _REGISTRY["WithClause"](self._pb.with_clause) if self._pb.HasField("with_clause") else None

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def all(self) -> bool:
        return self._pb.all

    @property
    def larg(self) -> SelectStmt | None:
        return _REGISTRY["SelectStmt"](self._pb.larg) if self._pb.HasField("larg") else None

    @property
    def rarg(self) -> SelectStmt | None:
        return _REGISTRY["SelectStmt"](self._pb.rarg) if self._pb.HasField("rarg") else None


class SetOperationStmt(AstNode):
    """Set operation (``UNION``, ``INTERSECT``, ``EXCEPT``, planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.SetOperationStmt
    __match_args__ = (
        "op",
        "all",
        "larg",
        "rarg",
        "col_types",
        "col_typmods",
        "col_collations",
        "group_clauses",
    )

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def all(self) -> bool:
        return self._pb.all

    @property
    def larg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.larg)

    @property
    def rarg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.rarg)

    @property
    def col_types(self) -> list[AstNode]:
        return _wrap_list(self._pb.col_types)

    @property
    def col_typmods(self) -> list[AstNode]:
        return _wrap_list(self._pb.col_typmods)

    @property
    def col_collations(self) -> list[AstNode]:
        return _wrap_list(self._pb.col_collations)

    @property
    def group_clauses(self) -> list[AstNode]:
        return _wrap_list(self._pb.group_clauses)


class SetToDefault(AstNode):
    """``DEFAULT`` keyword used as a value in ``INSERT`` or ``UPDATE``."""

    __slots__ = ()
    _pb: pg_query_pb2.SetToDefault
    __match_args__ = (
        "xpr",
        "type_id",
        "type_mod",
        "collation",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def type_id(self) -> int:
        return self._pb.type_id

    @property
    def type_mod(self) -> int:
        return self._pb.type_mod

    @property
    def collation(self) -> int:
        return self._pb.collation

    @property
    def location(self) -> int:
        return self._pb.location


class SinglePartitionSpec(AstNode):
    """Single partition specification (internal)."""

    __slots__ = ()
    _pb: pg_query_pb2.SinglePartitionSpec
    __match_args__ = ()
    pass


class SortBy(AstNode):
    """``ORDER BY`` sort specification."""

    __slots__ = ()
    _pb: pg_query_pb2.SortBy
    __match_args__ = (
        "node",
        "sortby_dir",
        "sortby_nulls",
        "use_op",
    )

    @property
    def node(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.node)

    @property
    def sortby_dir(self) -> int:
        return self._pb.sortby_dir

    @property
    def sortby_nulls(self) -> int:
        return self._pb.sortby_nulls

    @property
    def use_op(self) -> list[AstNode]:
        return _wrap_list(self._pb.use_op)

    @property
    def location(self) -> int:
        return self._pb.location


class SortGroupClause(AstNode):
    """Sort or group clause entry referencing a target list item (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.SortGroupClause
    __match_args__ = (
        "tle_sort_group_ref",
        "eqop",
        "sortop",
        "nulls_first",
        "hashable",
    )

    @property
    def tle_sort_group_ref(self) -> int:
        return self._pb.tle_sort_group_ref

    @property
    def eqop(self) -> int:
        return self._pb.eqop

    @property
    def sortop(self) -> int:
        return self._pb.sortop

    @property
    def nulls_first(self) -> bool:
        return self._pb.nulls_first

    @property
    def hashable(self) -> bool:
        return self._pb.hashable


class StatsElem(AstNode):
    """Column or expression element in a ``CREATE STATISTICS`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.StatsElem
    __match_args__ = (
        "name",
        "expr",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)


class String(AstNode):
    """String constant value."""

    __slots__ = ()
    _pb: pg_query_pb2.String
    __match_args__ = ("sval",)

    @property
    def sval(self) -> str:
        return self._pb.sval


class SubLink(AstNode):
    """Sub-``SELECT`` appearing in an expression (``EXISTS``, ``IN``, ``ANY``, scalar subquery, etc.)."""

    __slots__ = ()
    _pb: pg_query_pb2.SubLink
    __match_args__ = (
        "xpr",
        "sub_link_type",
        "sub_link_id",
        "testexpr",
        "oper_name",
        "subselect",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def sub_link_type(self) -> int:
        return self._pb.sub_link_type

    @property
    def sub_link_id(self) -> int:
        return self._pb.sub_link_id

    @property
    def testexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.testexpr)

    @property
    def oper_name(self) -> list[AstNode]:
        return _wrap_list(self._pb.oper_name)

    @property
    def subselect(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.subselect)

    @property
    def location(self) -> int:
        return self._pb.location


class SubPlan(AstNode):
    """Sub-plan reference in an expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.SubPlan
    __match_args__ = (
        "xpr",
        "sub_link_type",
        "testexpr",
        "param_ids",
        "plan_id",
        "plan_name",
        "first_col_type",
        "first_col_typmod",
        "first_col_collation",
        "use_hash_table",
        "unknown_eq_false",
        "parallel_safe",
        "set_param",
        "par_param",
        "args",
        "startup_cost",
        "per_call_cost",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def sub_link_type(self) -> int:
        return self._pb.sub_link_type

    @property
    def testexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.testexpr)

    @property
    def param_ids(self) -> list[AstNode]:
        return _wrap_list(self._pb.param_ids)

    @property
    def plan_id(self) -> int:
        return self._pb.plan_id

    @property
    def plan_name(self) -> str:
        return self._pb.plan_name

    @property
    def first_col_type(self) -> int:
        return self._pb.first_col_type

    @property
    def first_col_typmod(self) -> int:
        return self._pb.first_col_typmod

    @property
    def first_col_collation(self) -> int:
        return self._pb.first_col_collation

    @property
    def use_hash_table(self) -> bool:
        return self._pb.use_hash_table

    @property
    def unknown_eq_false(self) -> bool:
        return self._pb.unknown_eq_false

    @property
    def parallel_safe(self) -> bool:
        return self._pb.parallel_safe

    @property
    def set_param(self) -> list[AstNode]:
        return _wrap_list(self._pb.set_param)

    @property
    def par_param(self) -> list[AstNode]:
        return _wrap_list(self._pb.par_param)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def startup_cost(self) -> float:
        return self._pb.startup_cost

    @property
    def per_call_cost(self) -> float:
        return self._pb.per_call_cost


class SubscriptingRef(AstNode):
    """Array or container subscripting expression (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.SubscriptingRef
    __match_args__ = (
        "xpr",
        "refcontainertype",
        "refelemtype",
        "refrestype",
        "reftypmod",
        "refcollid",
        "refupperindexpr",
        "reflowerindexpr",
        "refexpr",
        "refassgnexpr",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def refcontainertype(self) -> int:
        return self._pb.refcontainertype

    @property
    def refelemtype(self) -> int:
        return self._pb.refelemtype

    @property
    def refrestype(self) -> int:
        return self._pb.refrestype

    @property
    def reftypmod(self) -> int:
        return self._pb.reftypmod

    @property
    def refcollid(self) -> int:
        return self._pb.refcollid

    @property
    def refupperindexpr(self) -> list[AstNode]:
        return _wrap_list(self._pb.refupperindexpr)

    @property
    def reflowerindexpr(self) -> list[AstNode]:
        return _wrap_list(self._pb.reflowerindexpr)

    @property
    def refexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.refexpr)

    @property
    def refassgnexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.refassgnexpr)


class SummaryResult(AstNode):
    """Result of SQL summarization (tables, functions, columns referenced)."""

    __slots__ = ()
    _pb: pg_query_pb2.SummaryResult
    __match_args__ = (
        "tables",
        "aliases",
        "cte_names",
        "functions",
        "filter_columns",
        "statement_types",
        "truncated_query",
    )

    @property
    def tables(self) -> list[SummaryResult_Table]:
        return [_REGISTRY["SummaryResult_Table"](item) for item in self._pb.tables]

    @property
    def aliases(self) -> list[SummaryResult_AliasesEntry]:
        return [_REGISTRY["SummaryResult_AliasesEntry"](item) for item in self._pb.aliases]

    @property
    def cte_names(self) -> list[str]:
        return list(self._pb.cte_names)

    @property
    def functions(self) -> list[SummaryResult_Function]:
        return [_REGISTRY["SummaryResult_Function"](item) for item in self._pb.functions]

    @property
    def filter_columns(self) -> list[SummaryResult_FilterColumn]:
        return [_REGISTRY["SummaryResult_FilterColumn"](item) for item in self._pb.filter_columns]

    @property
    def statement_types(self) -> list[str]:
        return list(self._pb.statement_types)

    @property
    def truncated_query(self) -> str:
        return self._pb.truncated_query


class SummaryResult_Table(AstNode):
    """Table referenced in a summarized SQL statement."""

    __slots__ = ()
    _pb: pg_query_pb2.SummaryResult.Table
    __match_args__ = (
        "name",
        "schema_name",
        "table_name",
        "context",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def schema_name(self) -> str:
        return self._pb.schema_name

    @property
    def table_name(self) -> str:
        return self._pb.table_name

    @property
    def context(self) -> int:
        return self._pb.context


class SummaryResult_AliasesEntry(AstNode):
    """Alias mapping entry in a summarized SQL statement."""

    __slots__ = ()
    _pb: pg_query_pb2.SummaryResult.AliasesEntry
    __match_args__ = (
        "key",
        "value",
    )

    @property
    def key(self) -> str:
        return self._pb.key

    @property
    def value(self) -> str:
        return self._pb.value


class SummaryResult_Function(AstNode):
    """Function referenced in a summarized SQL statement."""

    __slots__ = ()
    _pb: pg_query_pb2.SummaryResult.Function
    __match_args__ = (
        "name",
        "function_name",
        "schema_name",
        "context",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def function_name(self) -> str:
        return self._pb.function_name

    @property
    def schema_name(self) -> str:
        return self._pb.schema_name

    @property
    def context(self) -> int:
        return self._pb.context


class SummaryResult_FilterColumn(AstNode):
    """Column used in a filter (``WHERE``) in a summarized SQL statement."""

    __slots__ = ()
    _pb: pg_query_pb2.SummaryResult.FilterColumn
    __match_args__ = (
        "schema_name",
        "table_name",
        "column",
    )

    @property
    def schema_name(self) -> str:
        return self._pb.schema_name

    @property
    def table_name(self) -> str:
        return self._pb.table_name

    @property
    def column(self) -> str:
        return self._pb.column


class TableFunc(AstNode):
    """Table function definition (used by ``XMLTABLE`` and similar, planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.TableFunc
    __match_args__ = (
        "functype",
        "ns_uris",
        "ns_names",
        "docexpr",
        "rowexpr",
        "colnames",
        "coltypes",
        "coltypmods",
        "colcollations",
        "colexprs",
        "coldefexprs",
        "colvalexprs",
        "passingvalexprs",
        "notnulls",
        "plan",
        "ordinalitycol",
    )

    @property
    def functype(self) -> int:
        return self._pb.functype

    @property
    def ns_uris(self) -> list[AstNode]:
        return _wrap_list(self._pb.ns_uris)

    @property
    def ns_names(self) -> list[AstNode]:
        return _wrap_list(self._pb.ns_names)

    @property
    def docexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.docexpr)

    @property
    def rowexpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.rowexpr)

    @property
    def colnames(self) -> list[AstNode]:
        return _wrap_list(self._pb.colnames)

    @property
    def coltypes(self) -> list[AstNode]:
        return _wrap_list(self._pb.coltypes)

    @property
    def coltypmods(self) -> list[AstNode]:
        return _wrap_list(self._pb.coltypmods)

    @property
    def colcollations(self) -> list[AstNode]:
        return _wrap_list(self._pb.colcollations)

    @property
    def colexprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.colexprs)

    @property
    def coldefexprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.coldefexprs)

    @property
    def colvalexprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.colvalexprs)

    @property
    def passingvalexprs(self) -> list[AstNode]:
        return _wrap_list(self._pb.passingvalexprs)

    @property
    def notnulls(self) -> list[int]:
        return list(self._pb.notnulls)

    @property
    def plan(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.plan)

    @property
    def ordinalitycol(self) -> int:
        return self._pb.ordinalitycol

    @property
    def location(self) -> int:
        return self._pb.location


class TableLikeClause(AstNode):
    """``LIKE`` clause in ``CREATE TABLE`` (copies structure from another table)."""

    __slots__ = ()
    _pb: pg_query_pb2.TableLikeClause
    __match_args__ = (
        "relation",
        "options",
        "relation_oid",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def options(self) -> int:
        return self._pb.options

    @property
    def relation_oid(self) -> int:
        return self._pb.relation_oid


class TableSampleClause(AstNode):
    """``TABLESAMPLE`` clause (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.TableSampleClause
    __match_args__ = (
        "tsmhandler",
        "args",
        "repeatable",
    )

    @property
    def tsmhandler(self) -> int:
        return self._pb.tsmhandler

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def repeatable(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.repeatable)


class TargetEntry(AstNode):
    """Single entry in a query's target list (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.TargetEntry
    __match_args__ = (
        "xpr",
        "expr",
        "resno",
        "resname",
        "ressortgroupref",
        "resorigtbl",
        "resorigcol",
        "resjunk",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def resno(self) -> int:
        return self._pb.resno

    @property
    def resname(self) -> str:
        return self._pb.resname

    @property
    def ressortgroupref(self) -> int:
        return self._pb.ressortgroupref

    @property
    def resorigtbl(self) -> int:
        return self._pb.resorigtbl

    @property
    def resorigcol(self) -> int:
        return self._pb.resorigcol

    @property
    def resjunk(self) -> bool:
        return self._pb.resjunk


class TransactionStmt(AstNode):
    """Transaction control statement (``BEGIN``, ``COMMIT``, ``ROLLBACK``, ``SAVEPOINT``, etc.)."""

    __slots__ = ()
    _pb: pg_query_pb2.TransactionStmt
    __match_args__ = (
        "kind",
        "options",
        "savepoint_name",
        "gid",
        "chain",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def savepoint_name(self) -> str:
        return self._pb.savepoint_name

    @property
    def gid(self) -> str:
        return self._pb.gid

    @property
    def chain(self) -> bool:
        return self._pb.chain

    @property
    def location(self) -> int:
        return self._pb.location


class TriggerTransition(AstNode):
    """``REFERENCING`` transition table clause in ``CREATE TRIGGER``."""

    __slots__ = ()
    _pb: pg_query_pb2.TriggerTransition
    __match_args__ = (
        "name",
        "is_new",
        "is_table",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def is_new(self) -> bool:
        return self._pb.is_new

    @property
    def is_table(self) -> bool:
        return self._pb.is_table


class TruncateStmt(AstNode):
    """``TRUNCATE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.TruncateStmt
    __match_args__ = (
        "relations",
        "restart_seqs",
        "behavior",
    )

    @property
    def relations(self) -> list[AstNode]:
        return _wrap_list(self._pb.relations)

    @property
    def restart_seqs(self) -> bool:
        return self._pb.restart_seqs

    @property
    def behavior(self) -> int:
        return self._pb.behavior


class TypeCast(AstNode):
    """Type cast expression (``expr::type`` or ``CAST(expr AS type)``)."""

    __slots__ = ()
    _pb: pg_query_pb2.TypeCast
    __match_args__ = (
        "arg",
        "type_name",
    )

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def location(self) -> int:
        return self._pb.location


class TypeName(AstNode):
    """Type name with optional modifiers and array bounds."""

    __slots__ = ()
    _pb: pg_query_pb2.TypeName
    __match_args__ = (
        "names",
        "type_oid",
        "setof",
        "pct_type",
        "typmods",
        "typemod",
        "array_bounds",
    )

    @property
    def names(self) -> list[AstNode]:
        return _wrap_list(self._pb.names)

    @property
    def type_oid(self) -> int:
        return self._pb.type_oid

    @property
    def setof(self) -> bool:
        return self._pb.setof

    @property
    def pct_type(self) -> bool:
        return self._pb.pct_type

    @property
    def typmods(self) -> list[AstNode]:
        return _wrap_list(self._pb.typmods)

    @property
    def typemod(self) -> int:
        return self._pb.typemod

    @property
    def array_bounds(self) -> list[AstNode]:
        return _wrap_list(self._pb.array_bounds)

    @property
    def location(self) -> int:
        return self._pb.location


class UnlistenStmt(AstNode):
    """``UNLISTEN`` statement for notification channels."""

    __slots__ = ()
    _pb: pg_query_pb2.UnlistenStmt
    __match_args__ = ("conditionname",)

    @property
    def conditionname(self) -> str:
        return self._pb.conditionname


class UpdateStmt(AstNode):
    """``UPDATE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.UpdateStmt
    __match_args__ = (
        "relation",
        "target_list",
        "where_clause",
        "from_clause",
        "returning_list",
        "with_clause",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def target_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.target_list)

    @property
    def where_clause(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.where_clause)

    @property
    def from_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.from_clause)

    @property
    def returning_list(self) -> list[AstNode]:
        return _wrap_list(self._pb.returning_list)

    @property
    def with_clause(self) -> WithClause | None:
        return _REGISTRY["WithClause"](self._pb.with_clause) if self._pb.HasField("with_clause") else None


class VacuumRelation(AstNode):
    """Single relation in a ``VACUUM`` or ``ANALYZE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.VacuumRelation
    __match_args__ = (
        "relation",
        "oid",
        "va_cols",
    )

    @property
    def relation(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.relation) if self._pb.HasField("relation") else None

    @property
    def oid(self) -> int:
        return self._pb.oid

    @property
    def va_cols(self) -> list[AstNode]:
        return _wrap_list(self._pb.va_cols)


class VacuumStmt(AstNode):
    """``VACUUM`` and/or ``ANALYZE`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.VacuumStmt
    __match_args__ = (
        "options",
        "rels",
        "is_vacuumcmd",
    )

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def rels(self) -> list[AstNode]:
        return _wrap_list(self._pb.rels)

    @property
    def is_vacuumcmd(self) -> bool:
        return self._pb.is_vacuumcmd


class Var(AstNode):
    """Variable reference (column of a table, planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.Var
    __match_args__ = (
        "xpr",
        "varno",
        "varattno",
        "vartype",
        "vartypmod",
        "varcollid",
        "varnullingrels",
        "varlevelsup",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def varno(self) -> int:
        return self._pb.varno

    @property
    def varattno(self) -> int:
        return self._pb.varattno

    @property
    def vartype(self) -> int:
        return self._pb.vartype

    @property
    def vartypmod(self) -> int:
        return self._pb.vartypmod

    @property
    def varcollid(self) -> int:
        return self._pb.varcollid

    @property
    def varnullingrels(self) -> list[int]:
        return list(self._pb.varnullingrels)

    @property
    def varlevelsup(self) -> int:
        return self._pb.varlevelsup

    @property
    def location(self) -> int:
        return self._pb.location


class VariableSetStmt(AstNode):
    """``SET`` configuration variable statement."""

    __slots__ = ()
    _pb: pg_query_pb2.VariableSetStmt
    __match_args__ = (
        "kind",
        "name",
        "args",
        "is_local",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def is_local(self) -> bool:
        return self._pb.is_local


class VariableShowStmt(AstNode):
    """``SHOW`` configuration variable statement."""

    __slots__ = ()
    _pb: pg_query_pb2.VariableShowStmt
    __match_args__ = ("name",)

    @property
    def name(self) -> str:
        return self._pb.name


class ViewStmt(AstNode):
    """``CREATE VIEW`` statement."""

    __slots__ = ()
    _pb: pg_query_pb2.ViewStmt
    __match_args__ = (
        "view",
        "aliases",
        "query",
        "replace",
        "options",
        "with_check_option",
    )

    @property
    def view(self) -> RangeVar | None:
        return _REGISTRY["RangeVar"](self._pb.view) if self._pb.HasField("view") else None

    @property
    def aliases(self) -> list[AstNode]:
        return _wrap_list(self._pb.aliases)

    @property
    def query(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.query)

    @property
    def replace(self) -> bool:
        return self._pb.replace

    @property
    def options(self) -> list[AstNode]:
        return _wrap_list(self._pb.options)

    @property
    def with_check_option(self) -> int:
        return self._pb.with_check_option


class WindowClause(AstNode):
    """Window specification in a query plan (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.WindowClause
    __match_args__ = (
        "name",
        "refname",
        "partition_clause",
        "order_clause",
        "frame_options",
        "start_offset",
        "end_offset",
        "start_in_range_func",
        "end_in_range_func",
        "in_range_coll",
        "in_range_asc",
        "in_range_nulls_first",
        "winref",
        "copied_order",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def refname(self) -> str:
        return self._pb.refname

    @property
    def partition_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.partition_clause)

    @property
    def order_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.order_clause)

    @property
    def frame_options(self) -> int:
        return self._pb.frame_options

    @property
    def start_offset(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.start_offset)

    @property
    def end_offset(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.end_offset)

    @property
    def start_in_range_func(self) -> int:
        return self._pb.start_in_range_func

    @property
    def end_in_range_func(self) -> int:
        return self._pb.end_in_range_func

    @property
    def in_range_coll(self) -> int:
        return self._pb.in_range_coll

    @property
    def in_range_asc(self) -> bool:
        return self._pb.in_range_asc

    @property
    def in_range_nulls_first(self) -> bool:
        return self._pb.in_range_nulls_first

    @property
    def winref(self) -> int:
        return self._pb.winref

    @property
    def copied_order(self) -> bool:
        return self._pb.copied_order


class WindowDef(AstNode):
    """``WINDOW`` clause or inline window specification."""

    __slots__ = ()
    _pb: pg_query_pb2.WindowDef
    __match_args__ = (
        "name",
        "refname",
        "partition_clause",
        "order_clause",
        "frame_options",
        "start_offset",
        "end_offset",
    )

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def refname(self) -> str:
        return self._pb.refname

    @property
    def partition_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.partition_clause)

    @property
    def order_clause(self) -> list[AstNode]:
        return _wrap_list(self._pb.order_clause)

    @property
    def frame_options(self) -> int:
        return self._pb.frame_options

    @property
    def start_offset(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.start_offset)

    @property
    def end_offset(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.end_offset)

    @property
    def location(self) -> int:
        return self._pb.location


class WindowFunc(AstNode):
    """Window function call (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.WindowFunc
    __match_args__ = (
        "xpr",
        "winfnoid",
        "wintype",
        "wincollid",
        "inputcollid",
        "args",
        "aggfilter",
        "run_condition",
        "winref",
        "winstar",
        "winagg",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def winfnoid(self) -> int:
        return self._pb.winfnoid

    @property
    def wintype(self) -> int:
        return self._pb.wintype

    @property
    def wincollid(self) -> int:
        return self._pb.wincollid

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def aggfilter(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.aggfilter)

    @property
    def run_condition(self) -> list[AstNode]:
        return _wrap_list(self._pb.run_condition)

    @property
    def winref(self) -> int:
        return self._pb.winref

    @property
    def winstar(self) -> bool:
        return self._pb.winstar

    @property
    def winagg(self) -> bool:
        return self._pb.winagg

    @property
    def location(self) -> int:
        return self._pb.location


class WindowFuncRunCondition(AstNode):
    """Optimization condition for window function execution (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.WindowFuncRunCondition
    __match_args__ = (
        "xpr",
        "opno",
        "inputcollid",
        "wfunc_left",
        "arg",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def opno(self) -> int:
        return self._pb.opno

    @property
    def inputcollid(self) -> int:
        return self._pb.inputcollid

    @property
    def wfunc_left(self) -> bool:
        return self._pb.wfunc_left

    @property
    def arg(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.arg)


class WithCheckOption(AstNode):
    """``WITH CHECK OPTION`` for views and row-level security (planner node)."""

    __slots__ = ()
    _pb: pg_query_pb2.WithCheckOption
    __match_args__ = (
        "kind",
        "relname",
        "polname",
        "qual",
        "cascaded",
    )

    @property
    def kind(self) -> int:
        return self._pb.kind

    @property
    def relname(self) -> str:
        return self._pb.relname

    @property
    def polname(self) -> str:
        return self._pb.polname

    @property
    def qual(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.qual)

    @property
    def cascaded(self) -> bool:
        return self._pb.cascaded


class WithClause(AstNode):
    """``WITH`` clause containing common table expressions."""

    __slots__ = ()
    _pb: pg_query_pb2.WithClause
    __match_args__ = (
        "ctes",
        "recursive",
    )

    @property
    def ctes(self) -> list[AstNode]:
        return _wrap_list(self._pb.ctes)

    @property
    def recursive(self) -> bool:
        return self._pb.recursive

    @property
    def location(self) -> int:
        return self._pb.location


class XmlExpr(AstNode):
    """XML expression (``XMLCONCAT``, ``XMLELEMENT``, ``XMLFOREST``, etc.)."""

    __slots__ = ()
    _pb: pg_query_pb2.XmlExpr
    __match_args__ = (
        "xpr",
        "op",
        "name",
        "named_args",
        "arg_names",
        "args",
        "xmloption",
        "indent",
        "type",
        "typmod",
    )

    @property
    def xpr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.xpr)

    @property
    def op(self) -> int:
        return self._pb.op

    @property
    def name(self) -> str:
        return self._pb.name

    @property
    def named_args(self) -> list[AstNode]:
        return _wrap_list(self._pb.named_args)

    @property
    def arg_names(self) -> list[AstNode]:
        return _wrap_list(self._pb.arg_names)

    @property
    def args(self) -> list[AstNode]:
        return _wrap_list(self._pb.args)

    @property
    def xmloption(self) -> int:
        return self._pb.xmloption

    @property
    def indent(self) -> bool:
        return self._pb.indent

    @property
    def type(self) -> int:
        return self._pb.type

    @property
    def typmod(self) -> int:
        return self._pb.typmod

    @property
    def location(self) -> int:
        return self._pb.location


class XmlSerialize(AstNode):
    """``XMLSERIALIZE(content/document AS type)`` expression."""

    __slots__ = ()
    _pb: pg_query_pb2.XmlSerialize
    __match_args__ = (
        "xmloption",
        "expr",
        "type_name",
        "indent",
    )

    @property
    def xmloption(self) -> int:
        return self._pb.xmloption

    @property
    def expr(self) -> AstNode | None:
        return _wrap_node_optional(self._pb.expr)

    @property
    def type_name(self) -> TypeName | None:
        return _REGISTRY["TypeName"](self._pb.type_name) if self._pb.HasField("type_name") else None

    @property
    def indent(self) -> bool:
        return self._pb.indent

    @property
    def location(self) -> int:
        return self._pb.location


_REGISTRY.update({
    "A_ArrayExpr": A_ArrayExpr,
    "A_Const": A_Const,
    "A_Expr": A_Expr,
    "A_Indices": A_Indices,
    "A_Indirection": A_Indirection,
    "A_Star": A_Star,
    "AccessPriv": AccessPriv,
    "Aggref": Aggref,
    "Alias": Alias,
    "AlterCollationStmt": AlterCollationStmt,
    "AlterDatabaseRefreshCollStmt": AlterDatabaseRefreshCollStmt,
    "AlterDatabaseSetStmt": AlterDatabaseSetStmt,
    "AlterDatabaseStmt": AlterDatabaseStmt,
    "AlterDefaultPrivilegesStmt": AlterDefaultPrivilegesStmt,
    "AlterDomainStmt": AlterDomainStmt,
    "AlterEnumStmt": AlterEnumStmt,
    "AlterEventTrigStmt": AlterEventTrigStmt,
    "AlterExtensionContentsStmt": AlterExtensionContentsStmt,
    "AlterExtensionStmt": AlterExtensionStmt,
    "AlterFdwStmt": AlterFdwStmt,
    "AlterForeignServerStmt": AlterForeignServerStmt,
    "AlterFunctionStmt": AlterFunctionStmt,
    "AlterObjectDependsStmt": AlterObjectDependsStmt,
    "AlterObjectSchemaStmt": AlterObjectSchemaStmt,
    "AlterOpFamilyStmt": AlterOpFamilyStmt,
    "AlterOperatorStmt": AlterOperatorStmt,
    "AlterOwnerStmt": AlterOwnerStmt,
    "AlterPolicyStmt": AlterPolicyStmt,
    "AlterPublicationStmt": AlterPublicationStmt,
    "AlterRoleSetStmt": AlterRoleSetStmt,
    "AlterRoleStmt": AlterRoleStmt,
    "AlterSeqStmt": AlterSeqStmt,
    "AlterStatsStmt": AlterStatsStmt,
    "AlterSubscriptionStmt": AlterSubscriptionStmt,
    "AlterSystemStmt": AlterSystemStmt,
    "AlterTSConfigurationStmt": AlterTSConfigurationStmt,
    "AlterTSDictionaryStmt": AlterTSDictionaryStmt,
    "AlterTableCmd": AlterTableCmd,
    "AlterTableMoveAllStmt": AlterTableMoveAllStmt,
    "AlterTableSpaceOptionsStmt": AlterTableSpaceOptionsStmt,
    "AlterTableStmt": AlterTableStmt,
    "AlterTypeStmt": AlterTypeStmt,
    "AlterUserMappingStmt": AlterUserMappingStmt,
    "AlternativeSubPlan": AlternativeSubPlan,
    "ArrayCoerceExpr": ArrayCoerceExpr,
    "ArrayExpr": ArrayExpr,
    "BitString": BitString,
    "BoolExpr": BoolExpr,
    "Boolean": Boolean,
    "BooleanTest": BooleanTest,
    "CTECycleClause": CTECycleClause,
    "CTESearchClause": CTESearchClause,
    "CallContext": CallContext,
    "CallStmt": CallStmt,
    "CaseExpr": CaseExpr,
    "CaseTestExpr": CaseTestExpr,
    "CaseWhen": CaseWhen,
    "CheckPointStmt": CheckPointStmt,
    "ClosePortalStmt": ClosePortalStmt,
    "ClusterStmt": ClusterStmt,
    "CoalesceExpr": CoalesceExpr,
    "CoerceToDomain": CoerceToDomain,
    "CoerceToDomainValue": CoerceToDomainValue,
    "CoerceViaIO": CoerceViaIO,
    "CollateClause": CollateClause,
    "CollateExpr": CollateExpr,
    "ColumnDef": ColumnDef,
    "ColumnRef": ColumnRef,
    "CommentStmt": CommentStmt,
    "CommonTableExpr": CommonTableExpr,
    "CompositeTypeStmt": CompositeTypeStmt,
    "Constraint": Constraint,
    "ConstraintsSetStmt": ConstraintsSetStmt,
    "ConvertRowtypeExpr": ConvertRowtypeExpr,
    "CopyStmt": CopyStmt,
    "CreateAmStmt": CreateAmStmt,
    "CreateCastStmt": CreateCastStmt,
    "CreateConversionStmt": CreateConversionStmt,
    "CreateDomainStmt": CreateDomainStmt,
    "CreateEnumStmt": CreateEnumStmt,
    "CreateEventTrigStmt": CreateEventTrigStmt,
    "CreateExtensionStmt": CreateExtensionStmt,
    "CreateFdwStmt": CreateFdwStmt,
    "CreateForeignServerStmt": CreateForeignServerStmt,
    "CreateForeignTableStmt": CreateForeignTableStmt,
    "CreateFunctionStmt": CreateFunctionStmt,
    "CreateOpClassItem": CreateOpClassItem,
    "CreateOpClassStmt": CreateOpClassStmt,
    "CreateOpFamilyStmt": CreateOpFamilyStmt,
    "CreatePLangStmt": CreatePLangStmt,
    "CreatePolicyStmt": CreatePolicyStmt,
    "CreatePublicationStmt": CreatePublicationStmt,
    "CreateRangeStmt": CreateRangeStmt,
    "CreateRoleStmt": CreateRoleStmt,
    "CreateSchemaStmt": CreateSchemaStmt,
    "CreateSeqStmt": CreateSeqStmt,
    "CreateStatsStmt": CreateStatsStmt,
    "CreateStmt": CreateStmt,
    "CreateSubscriptionStmt": CreateSubscriptionStmt,
    "CreateTableAsStmt": CreateTableAsStmt,
    "CreateTableSpaceStmt": CreateTableSpaceStmt,
    "CreateTransformStmt": CreateTransformStmt,
    "CreateTrigStmt": CreateTrigStmt,
    "CreateUserMappingStmt": CreateUserMappingStmt,
    "CreatedbStmt": CreatedbStmt,
    "CurrentOfExpr": CurrentOfExpr,
    "DeallocateStmt": DeallocateStmt,
    "DeclareCursorStmt": DeclareCursorStmt,
    "DefElem": DefElem,
    "DefineStmt": DefineStmt,
    "DeleteStmt": DeleteStmt,
    "DiscardStmt": DiscardStmt,
    "DistinctExpr": DistinctExpr,
    "DoStmt": DoStmt,
    "DropOwnedStmt": DropOwnedStmt,
    "DropRoleStmt": DropRoleStmt,
    "DropStmt": DropStmt,
    "DropSubscriptionStmt": DropSubscriptionStmt,
    "DropTableSpaceStmt": DropTableSpaceStmt,
    "DropUserMappingStmt": DropUserMappingStmt,
    "DropdbStmt": DropdbStmt,
    "ExecuteStmt": ExecuteStmt,
    "ExplainStmt": ExplainStmt,
    "FetchStmt": FetchStmt,
    "FieldSelect": FieldSelect,
    "FieldStore": FieldStore,
    "Float": Float,
    "FromExpr": FromExpr,
    "FuncCall": FuncCall,
    "FuncExpr": FuncExpr,
    "FunctionParameter": FunctionParameter,
    "GrantRoleStmt": GrantRoleStmt,
    "GrantStmt": GrantStmt,
    "GroupingFunc": GroupingFunc,
    "GroupingSet": GroupingSet,
    "ImportForeignSchemaStmt": ImportForeignSchemaStmt,
    "IndexElem": IndexElem,
    "IndexStmt": IndexStmt,
    "InferClause": InferClause,
    "InferenceElem": InferenceElem,
    "InlineCodeBlock": InlineCodeBlock,
    "InsertStmt": InsertStmt,
    "IntList": IntList,
    "Integer": Integer,
    "IntoClause": IntoClause,
    "JoinExpr": JoinExpr,
    "JsonAggConstructor": JsonAggConstructor,
    "JsonArgument": JsonArgument,
    "JsonArrayAgg": JsonArrayAgg,
    "JsonArrayConstructor": JsonArrayConstructor,
    "JsonArrayQueryConstructor": JsonArrayQueryConstructor,
    "JsonBehavior": JsonBehavior,
    "JsonConstructorExpr": JsonConstructorExpr,
    "JsonExpr": JsonExpr,
    "JsonFormat": JsonFormat,
    "JsonFuncExpr": JsonFuncExpr,
    "JsonIsPredicate": JsonIsPredicate,
    "JsonKeyValue": JsonKeyValue,
    "JsonObjectAgg": JsonObjectAgg,
    "JsonObjectConstructor": JsonObjectConstructor,
    "JsonOutput": JsonOutput,
    "JsonParseExpr": JsonParseExpr,
    "JsonReturning": JsonReturning,
    "JsonScalarExpr": JsonScalarExpr,
    "JsonSerializeExpr": JsonSerializeExpr,
    "JsonTable": JsonTable,
    "JsonTableColumn": JsonTableColumn,
    "JsonTablePath": JsonTablePath,
    "JsonTablePathScan": JsonTablePathScan,
    "JsonTablePathSpec": JsonTablePathSpec,
    "JsonTableSiblingJoin": JsonTableSiblingJoin,
    "JsonValueExpr": JsonValueExpr,
    "List": List,
    "ListenStmt": ListenStmt,
    "LoadStmt": LoadStmt,
    "LockStmt": LockStmt,
    "LockingClause": LockingClause,
    "MergeAction": MergeAction,
    "MergeStmt": MergeStmt,
    "MergeSupportFunc": MergeSupportFunc,
    "MergeWhenClause": MergeWhenClause,
    "MinMaxExpr": MinMaxExpr,
    "MultiAssignRef": MultiAssignRef,
    "NamedArgExpr": NamedArgExpr,
    "NextValueExpr": NextValueExpr,
    "NotifyStmt": NotifyStmt,
    "NullIfExpr": NullIfExpr,
    "NullTest": NullTest,
    "ObjectWithArgs": ObjectWithArgs,
    "OidList": OidList,
    "OnConflictClause": OnConflictClause,
    "OnConflictExpr": OnConflictExpr,
    "OpExpr": OpExpr,
    "PLAssignStmt": PLAssignStmt,
    "Param": Param,
    "ParamRef": ParamRef,
    "ParseResult": ParseResult,
    "PartitionBoundSpec": PartitionBoundSpec,
    "PartitionCmd": PartitionCmd,
    "PartitionElem": PartitionElem,
    "PartitionRangeDatum": PartitionRangeDatum,
    "PartitionSpec": PartitionSpec,
    "PrepareStmt": PrepareStmt,
    "PublicationObjSpec": PublicationObjSpec,
    "PublicationTable": PublicationTable,
    "Query": Query,
    "RTEPermissionInfo": RTEPermissionInfo,
    "RangeFunction": RangeFunction,
    "RangeSubselect": RangeSubselect,
    "RangeTableFunc": RangeTableFunc,
    "RangeTableFuncCol": RangeTableFuncCol,
    "RangeTableSample": RangeTableSample,
    "RangeTblEntry": RangeTblEntry,
    "RangeTblFunction": RangeTblFunction,
    "RangeTblRef": RangeTblRef,
    "RangeVar": RangeVar,
    "RawStmt": RawStmt,
    "ReassignOwnedStmt": ReassignOwnedStmt,
    "RefreshMatViewStmt": RefreshMatViewStmt,
    "ReindexStmt": ReindexStmt,
    "RelabelType": RelabelType,
    "RenameStmt": RenameStmt,
    "ReplicaIdentityStmt": ReplicaIdentityStmt,
    "ResTarget": ResTarget,
    "ReturnStmt": ReturnStmt,
    "RoleSpec": RoleSpec,
    "RowCompareExpr": RowCompareExpr,
    "RowExpr": RowExpr,
    "RowMarkClause": RowMarkClause,
    "RuleStmt": RuleStmt,
    "SQLValueFunction": SQLValueFunction,
    "ScalarArrayOpExpr": ScalarArrayOpExpr,
    "ScanResult": ScanResult,
    "ScanToken": ScanToken,
    "SecLabelStmt": SecLabelStmt,
    "SelectStmt": SelectStmt,
    "SetOperationStmt": SetOperationStmt,
    "SetToDefault": SetToDefault,
    "SinglePartitionSpec": SinglePartitionSpec,
    "SortBy": SortBy,
    "SortGroupClause": SortGroupClause,
    "StatsElem": StatsElem,
    "String": String,
    "SubLink": SubLink,
    "SubPlan": SubPlan,
    "SubscriptingRef": SubscriptingRef,
    "SummaryResult": SummaryResult,
    "Table": SummaryResult_Table,
    "AliasesEntry": SummaryResult_AliasesEntry,
    "Function": SummaryResult_Function,
    "FilterColumn": SummaryResult_FilterColumn,
    "TableFunc": TableFunc,
    "TableLikeClause": TableLikeClause,
    "TableSampleClause": TableSampleClause,
    "TargetEntry": TargetEntry,
    "TransactionStmt": TransactionStmt,
    "TriggerTransition": TriggerTransition,
    "TruncateStmt": TruncateStmt,
    "TypeCast": TypeCast,
    "TypeName": TypeName,
    "UnlistenStmt": UnlistenStmt,
    "UpdateStmt": UpdateStmt,
    "VacuumRelation": VacuumRelation,
    "VacuumStmt": VacuumStmt,
    "Var": Var,
    "VariableSetStmt": VariableSetStmt,
    "VariableShowStmt": VariableShowStmt,
    "ViewStmt": ViewStmt,
    "WindowClause": WindowClause,
    "WindowDef": WindowDef,
    "WindowFunc": WindowFunc,
    "WindowFuncRunCondition": WindowFuncRunCondition,
    "WithCheckOption": WithCheckOption,
    "WithClause": WithClause,
    "XmlExpr": XmlExpr,
    "XmlSerialize": XmlSerialize,
})
